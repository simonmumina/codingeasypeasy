---
title: 'Spring Boot REST API Tutorial: Build a Complete CRUD Example'
date: '2024-10-26'
lastmod: '2024-10-26'
tags: ['spring boot', 'rest api', 'java', 'crud', 'tutorial', 'web development']
draft: false
summary: 'Learn how to create a robust and functional REST API using Spring Boot. This comprehensive tutorial covers all the steps, from project setup to implementing CRUD operations with code examples.'
authors: ['default']
---

# Spring Boot REST API Tutorial: Build a Complete CRUD Example

This tutorial guides you through creating a REST API using Spring Boot. We'll cover the fundamentals, from setting up your project to implementing Create, Read, Update, and Delete (CRUD) operations. This guide is designed for beginners who want to learn how to build robust and scalable web services with Spring Boot.

## What is a REST API?

A REST (Representational State Transfer) API is an architectural style for designing networked applications. It relies on a stateless client-server communication protocol, typically HTTP, to exchange data in a structured format (usually JSON or XML). REST APIs are widely used for building web services and mobile applications because they offer a simple and flexible way to interact with data.

## Why Spring Boot for REST APIs?

Spring Boot simplifies the development of Spring-based applications by providing auto-configuration, embedded servers, and a minimal setup experience. It's an excellent choice for building REST APIs because:

- **Ease of Use:** Spring Boot streamlines the configuration process, reducing boilerplate code.
- **Embedded Servers:** It includes embedded servers like Tomcat, Jetty, and Undertow, making deployment straightforward.
- **Dependency Management:** Spring Boot's dependency management system simplifies adding and managing dependencies.
- **Spring Data:** Spring Data provides convenient abstractions for data access, making it easy to interact with databases.
- **Spring MVC:** Spring MVC offers a robust framework for handling HTTP requests and responses.

## Prerequisites

Before you start, make sure you have the following installed:

- **Java Development Kit (JDK) 8 or higher:** Download and install the latest JDK from Oracle or OpenJDK.
- **Maven or Gradle:** A build tool for managing dependencies and building your project. We'll use Maven in this tutorial.
- **Integrated Development Environment (IDE):** An IDE like IntelliJ IDEA, Eclipse, or VS Code will make your development process easier.

## Project Setup

1.  **Create a New Spring Boot Project:** You can create a new Spring Boot project using Spring Initializr ([https://start.spring.io/](https://start.spring.io/)). Configure the following:

    - **Project:** Maven
    - **Language:** Java
    - **Spring Boot:** Choose the latest stable version (e.g., 3.1.5)
    - **Group:** `com.example` (or your preferred group ID)
    - **Artifact:** `rest-api-demo` (or your preferred artifact ID)
    - **Packaging:** Jar
    - **Java:** 17 (or your installed JDK version)
    - **Dependencies:** Add the following dependencies:
      - `Spring Web` (for building REST controllers)
      - `Spring Data JPA` (for data access)
      - `H2 Database` (an in-memory database for development)
      - `Lombok` (optional, for reducing boilerplate code)

2.  **Download and Extract the Project:** Download the generated project and extract it to your desired location.

3.  **Import the Project into your IDE:** Import the project as a Maven project into your IDE.

## Defining the Data Model

Let's create a simple data model for our REST API. We'll use a `Product` entity with attributes like `id`, `name`, and `price`.

Create a new package named `com.example.restapidemo.model` and add a new class called `Product.java`:

```plaintext
package com.example.restapidemo.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private double price;
}
```

**Explanation:**

- `@Entity`: Marks the class as a JPA entity, indicating that it represents a table in the database.
- `@Id`: Specifies the primary key of the entity.
- `@GeneratedValue`: Configures the generation strategy for the primary key. `GenerationType.IDENTITY` indicates that the database will generate the primary key.
- `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`: These annotations are provided by Lombok and automatically generate getters, setters, `toString`, `equals`, `hashCode`, a no-argument constructor, and an all-argument constructor. (If you don't use Lombok, you'll need to manually create these methods).

## Creating the Repository

Next, we'll create a repository interface to interact with the database. Spring Data JPA provides a convenient way to create repositories with minimal code.

Create a new package named `com.example.restapidemo.repository` and add a new interface called `ProductRepository.java`:

```plaintext
package com.example.restapidemo.repository;

import com.example.restapidemo.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // You can add custom query methods here if needed
}
```

**Explanation:**

- `@Repository`: Marks the interface as a Spring component and indicates that it's a data repository.
- `JpaRepository<Product, Long>`: Extends the `JpaRepository` interface, which provides methods for performing CRUD operations on the `Product` entity, using `Long` as the type of the primary key. You don't need to implement this interface; Spring Data JPA will automatically provide an implementation at runtime.

## Building the REST Controller

Now, let's create the REST controller that will handle HTTP requests and interact with the `ProductRepository`.

Create a new package named `com.example.restapidemo.controller` and add a new class called `ProductController.java`:

```plaintext
package com.example.restapidemo.controller;

import com.example.restapidemo.model.Product;
import com.example.restapidemo.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductRepository productRepository;

    @GetMapping
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }

    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        return productRepository.findById(id)
                .map(product -> new ResponseEntity<>(product, HttpStatus.OK))
                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody Product product) {
        Product savedProduct = productRepository.save(product);
        return new ResponseEntity<>(savedProduct, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long id, @RequestBody Product product) {
        return productRepository.findById(id)
                .map(existingProduct -> {
                    product.setId(id); // Ensure the ID is set for update
                    Product updatedProduct = productRepository.save(product);
                    return new ResponseEntity<>(updatedProduct, HttpStatus.OK);
                })
                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        if (productRepository.existsById(id)) {
            productRepository.deleteById(id);
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } else {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }
}
```

**Explanation:**

- `@RestController`: Indicates that this class is a REST controller, which handles incoming HTTP requests.
- `@RequestMapping("/api/products")`: Maps all requests to this controller to the `/api/products` path.
- `@Autowired`: Injects the `ProductRepository` dependency into the controller.
- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`: Map HTTP methods (GET, POST, PUT, DELETE) to specific handler methods.
- `@PathVariable`: Extracts values from the URL path.
- `@RequestBody`: Binds the request body to a method parameter.
- `ResponseEntity`: Represents an HTTP response, allowing you to control the status code, headers, and body.
- `HttpStatus`: Provides standard HTTP status codes.
- `productRepository.findAll()`, `productRepository.findById()`, `productRepository.save()`, `productRepository.deleteById()`: Methods from the `ProductRepository` interface to perform CRUD operations on the database.

## Configuring the Database

Since we're using H2, an in-memory database, we need to configure it in our `application.properties` file.

Open the `src/main/resources/application.properties` file and add the following:

```properties
spring.application.name=rest-api-demo
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.h2.console.enabled=true
```

**Explanation:**

- `spring.datasource.url`: Specifies the URL for the H2 database (in-memory).
- `spring.datasource.driverClassName`: Specifies the driver class name for H2.
- `spring.datasource.username`, `spring.datasource.password`: Specifies the username and password for the database. (In this case, the password is empty).
- `spring.jpa.database-platform`: Specifies the database platform for JPA.
- `spring.jpa.hibernate.ddl-auto=update`: Automatically updates the database schema based on the entity mappings. (Use `create-drop` for development to recreate the database on each startup, but avoid using it in production).
- `spring.h2.console.enabled=true`: Enables the H2 console, which allows you to view and manage the database. You can access it at `http://localhost:8080/h2-console`. Make sure to set the JDBC URL to `jdbc:h2:mem:testdb` in the console.

## Running the Application

Now you're ready to run the Spring Boot application. In your IDE, run the `RestApiDemoApplication.java` class (the main application class).

Once the application is running, you can test the REST API endpoints using a tool like Postman, Insomnia, or `curl`.

## Testing the API Endpoints

Here are some examples of how to test the API endpoints:

**1. Get All Products (GET /api/products):**

```plaintext
curl http://localhost:8080/api/products
```

**2. Get Product by ID (GET /api/products/{id}):**

```plaintext
curl http://localhost:8080/api/products/1
```

**3. Create a Product (POST /api/products):**

```plaintext
curl -X POST \
  http://localhost:8080/api/products \
  -H 'Content-Type: application/json' \
  -d '{
    "name": "Example Product",
    "price": 29.99
  }'
```

**4. Update a Product (PUT /api/products/{id}):**

```plaintext
curl -X PUT \
  http://localhost:8080/api/products/1 \
  -H 'Content-Type: application/json' \
  -d '{
    "id": 1,
    "name": "Updated Product Name",
    "price": 39.99
  }'
```

**5. Delete a Product (DELETE /api/products/{id}):**

```plaintext
curl -X DELETE http://localhost:8080/api/products/1
```

## Conclusion

This tutorial provided a comprehensive guide to creating a REST API using Spring Boot. We covered project setup, data model definition, repository creation, REST controller implementation, database configuration, and testing. You can now use this knowledge to build more complex and sophisticated REST APIs. Remember to consult the official Spring Boot documentation for more advanced features and configurations. Happy coding!
