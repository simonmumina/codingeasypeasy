---
title: 'JavaScript Operator Precedence: Demystifying Order of Operations with Examples'
date: '2024-10-27'
lastmod: '2024-10-27'
tags:
  ['javascript', 'operator precedence', 'order of operations', 'programming', 'coding', 'developer']
draft: false
summary: 'Unlock the secrets of JavaScript operator precedence! Understand how JavaScript evaluates expressions, prevent unexpected bugs, and write cleaner, more maintainable code with practical examples and explanations.'
authors: ['default']
---

# JavaScript Operator Precedence: Demystifying Order of Operations with Examples

Understanding JavaScript operator precedence is crucial for writing correct and predictable code. It dictates the order in which operators are applied in an expression, significantly impacting the final result. Ignoring operator precedence can lead to unexpected bugs and make your code harder to debug. This blog post will break down operator precedence in JavaScript, providing clear explanations and real-world examples to help you master this fundamental concept.

## What is Operator Precedence?

Operator precedence defines the order in which operators are evaluated in a complex expression. Think of it like the order of operations you learned in math (PEMDAS/BODMAS). JavaScript has a set of rules that determine which operator is executed first. Operators with higher precedence are executed before operators with lower precedence.

For instance, multiplication and division generally have higher precedence than addition and subtraction. Therefore, in the expression `2 + 3 * 4`, the multiplication (`3 * 4`) is performed _before_ the addition (`2 + 12`), resulting in `14`, not `20`.

## Why is Understanding Operator Precedence Important?

- **Preventing Bugs:** Incorrect assumptions about operator precedence can lead to unexpected behavior and difficult-to-find bugs.
- **Writing Readable Code:** Understanding precedence allows you to write code that clearly expresses your intended logic. Using parentheses can further clarify intent.
- **Maintaining Code:** Knowing how operators interact makes your code easier to understand and maintain, especially for other developers working on your project.
- **Optimization (to a small degree):** While micro-optimizations should not be the primary goal, understanding how the interpreter works can sometimes help write marginally more efficient code.

## The JavaScript Operator Precedence Table

The following table shows the precedence of JavaScript operators, from highest to lowest. Remember to consult the official Mozilla Developer Network (MDN) documentation for the most up-to-date and comprehensive information. This is a simplified version for clarity.

| Precedence | Operator Type                                                                                                      | Associativity | Examples                                                                                                                              |
| ---------- | ------------------------------------------------------------------------------------------------------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 21         | Grouping                                                                                                           | N/A           | `(expression)`                                                                                                                        |
| 20         | Member Access, Computed Member Access, new (with arguments)                                                        | Left-to-right | `object.property`, `object[property]`, `new Class(arguments)`                                                                         |
| 19         | Function Call, new (without arguments), Postfix Increment/Decrement                                                | Left-to-right | `function()`, `new Class`, `x++`, `x--`                                                                                               |
| 18         | Logical NOT, Bitwise NOT, Unary Plus, Unary Minus, Prefix Increment/Decrement, `typeof`, `void`, `delete`, `await` | Right-to-left | `!x`, `~x`, `+x`, `-x`, `++x`, `--x`, `typeof x`, `void x`, `delete object.property`, `await promise`                                 |
| 17         | Exponentiation                                                                                                     | Right-to-left | `x ** y`                                                                                                                              |
| 16         | Multiplication, Division, Remainder                                                                                | Left-to-right | `x * y`, `x / y`, `x % y`                                                                                                             |
| 15         | Addition, Subtraction                                                                                              | Left-to-right | `x + y`, `x - y`                                                                                                                      |
| 14         | Bitwise Left Shift, Bitwise Right Shift, Unsigned Right Shift                                                      | Left-to-right | `x << y`, `x >> y`, `x >>> y`                                                                                                         |
| 13         | Relational (less than, greater than, etc.), `in`, `instanceof`                                                     | Left-to-right | `x < y`, `x > y`, `x <= y`, `x >= y`, `property in object`, `object instanceof Class`                                                 |
| 12         | Equality (strict equality, strict inequality, etc.)                                                                | Left-to-right | `x === y`, `x !== y`, `x == y`, `x != y`                                                                                              |
| 11         | Bitwise AND                                                                                                        | Left-to-right | `x & y`                                                                                                                               |
| 10         | Bitwise XOR                                                                                                        | Left-to-right | `x ^ y`                                                                                                                               |
| 9          | Bitwise OR                                                                                                         | Left-to-right | `x \| y`                                                                                                                              |
| 8          | Logical AND                                                                                                        | Left-to-right | `x && y`                                                                                                                              |
| 7          | Logical OR                                                                                                         | Left-to-right | `x \|\| y`                                                                                                                            |
| 6          | Nullish Coalescing Operator                                                                                        | Right-to-left | `x ?? y`                                                                                                                              |
| 5          | Conditional (ternary) Operator                                                                                     | Right-to-left | `condition ? valueIfTrue : valueIfFalse`                                                                                              |
| 4          | Assignment Operators                                                                                               | Right-to-left | `x = y`, `x += y`, `x -= y`, `x *= y`, `x /= y`, `x %= y`, `x **= y`, `x <<= y`, `x >>= y`, `x >>>= y`, `x &= y`, `x ^= y`, `x \|= y` |
| 3          | `yield`, `yield*`                                                                                                  | Right-to-left | `yield value`, `yield* iterable`                                                                                                      |
| 2          | Spread Syntax                                                                                                      | N/A           | `...iterable`                                                                                                                         |
| 1          | Comma Operator                                                                                                     | Left-to-right | `x, y` (Evaluates both `x` and `y` but returns the value of `y`.)                                                                     |

**Key Concepts to Note:**

- **Associativity:** Determines the order in which operators of the _same_ precedence are evaluated. Left-to-right means they are evaluated from left to right, while right-to-left means they are evaluated from right to left.
- **Grouping (Parentheses):** Operators within parentheses `()` have the highest precedence. Use parentheses to explicitly control the order of evaluation and improve code readability.

## Operator Precedence in Action: Examples

Let's explore several examples to illustrate how operator precedence works in practice.

**Example 1: Arithmetic Operators**

```plaintext
let result = 2 + 3 * 4;
console.log(result); // Output: 14 (Multiplication is performed before addition)

let resultWithParentheses = (2 + 3) * 4;
console.log(resultWithParentheses); // Output: 20 (Parentheses force addition to be performed first)
```

In the first example, `3 * 4` is evaluated before `2 +`, due to multiplication's higher precedence. In the second example, the parentheses ensure that `2 + 3` is calculated first.

**Example 2: Logical Operators**

```plaintext
let a = true;
let b = false;
let c = true;

let result = a && b || c;
console.log(result); // Output: true (&& has higher precedence than ||)

let resultWithParentheses = a && (b || c);
console.log(resultWithParentheses); // Output: false (Parentheses change the order of evaluation)
```

Without parentheses, `a && b` is evaluated first (resulting in `false`), then `false || c` which results in `true`. The parentheses in the second example force `b || c` to be evaluated first (resulting in `true`), then `a && true` which results in `false`.

**Example 3: Assignment Operators**

Assignment operators have very low precedence.

```plaintext
let x = 5;
let y = 2;

let result = x = y + 3; // Assignment returns the value assigned.
console.log(result); // Output: 5
console.log(x); // Output: 5 (x is now 5)
console.log(y); // Output: 2
```

In this case, `y + 3` is evaluated first (`2 + 3 = 5`), and then the result is assigned to `x`. The assignment operation itself returns the assigned value, which is then assigned to `result`.

**Example 4: Increment and Decrement Operators**

Be careful with prefix and postfix increment/decrement operators and their interaction with other operators.

```plaintext
let x = 5;
let y = x++; // Postfix increment:  `x` is incremented *after* its value is used
console.log(x); // Output: 6
console.log(y); // Output: 5 (y gets the *original* value of x)

let a = 5;
let b = ++a; // Prefix increment: `a` is incremented *before* its value is used
console.log(a); // Output: 6
console.log(b); // Output: 6 (b gets the *incremented* value of a)
```

Postfix increment (`x++`) returns the _original_ value of `x` _before_ incrementing it. Prefix increment (`++a`) returns the _incremented_ value of `a`.

**Example 5: The Comma Operator**

The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand.

```plaintext
let x = (1, 2, 3);
console.log(x); // Output: 3

let a, b;
a = (b = 3, b + 2);
console.log(a); // Output: 5
console.log(b); // Output: 3
```

While the comma operator exists, its use can often lead to less readable code. It is generally better to avoid it, except in specific cases like within a `for` loop.

**Example 6: Nullish Coalescing Operator (`??`)**

The nullish coalescing operator returns its right-hand side operand when its left-hand side operand is `null` or `undefined`, and otherwise returns its left-hand side operand.

```plaintext
let name = null;
let defaultName = "Guest";

let displayName = name ?? defaultName;
console.log(displayName); // Output: Guest (name is null, so defaultName is used)

name = "Alice";
displayName = name ?? defaultName;
console.log(displayName); // Output: Alice (name is not null, so name is used)

let zero = 0;
let defaultNumber = 10;

//Important Difference between ?? and ||
let resultOr = zero || defaultNumber; //returns 10 since 0 is falsy
let resultNullish = zero ?? defaultNumber //returns 0 since 0 is NOT null or undefined

console.log(resultOr); // Output: 10
console.log(resultNullish); // Output: 0
```

The `??` operator is particularly useful for providing default values when a variable might be null or undefined, and critically, treating `0` or `""` as valid values (unlike the `||` operator).

## Best Practices and Recommendations

- **Use Parentheses:** Don't rely solely on your memory of the operator precedence table. Use parentheses to explicitly define the order of operations, even when it's not strictly necessary. This makes your code more readable and reduces the chance of errors.
- **Consult the MDN Documentation:** The MDN Web Docs (Mozilla Developer Network) are your primary source for accurate and up-to-date information about JavaScript operator precedence. Always refer to MDN when in doubt.
- **Write Clear and Concise Code:** Break down complex expressions into smaller, more manageable pieces. This enhances readability and reduces the risk of misinterpreting operator precedence.
- **Test Your Code:** Thoroughly test your code to ensure that operators are behaving as expected. Write unit tests to verify that expressions are evaluated correctly.
- **Linting Tools:** Use linting tools like ESLint to enforce coding standards and catch potential errors related to operator precedence.

## Conclusion

Mastering JavaScript operator precedence is a vital skill for any JavaScript developer. By understanding the order in which operators are evaluated, you can write cleaner, more predictable, and less error-prone code. Remember to prioritize readability by using parentheses and to consult the MDN documentation whenever you're unsure about operator precedence. Happy coding!
