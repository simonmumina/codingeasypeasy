---
title: 'Node.js: How to Recursively Copy Folders with Examples'
date: '2024-10-26'
lastmod: '2024-10-27'
tags: ['nodejs', 'filesystem', 'recursive copy', 'folder copy', 'fs-extra', 'javascript']
draft: false
summary: 'Learn how to recursively copy folders in Node.js using built-in modules and external libraries like fs-extra. This guide provides detailed explanations and practical code examples for efficient folder duplication.'
authors: ['default']
---

# Node.js: How to Recursively Copy Folders with Examples

Copying folders recursively in Node.js is a common task when dealing with file system operations, such as creating backups, deploying applications, or organizing files. This process involves traversing the folder structure, copying files, and recreating the directory hierarchy at the destination.  This blog post explores several methods for achieving this, using both built-in Node.js modules and external libraries, with detailed explanations and practical code examples.

## Why Recursive Folder Copying?

Before diving into the implementation, let's understand why recursive folder copying is important:

*   **Backups:** Creating a complete copy of a directory as a backup in case of data loss.
*   **Deployment:** Copying application files and directories to a server for deployment.
*   **File Management:** Organizing and duplicating files within a file system.
*   **Application Development:**  Duplicating project templates or generating project structures.

## Method 1: Using Node.js Built-in Modules (`fs` and `path`)

Node.js provides the `fs` (file system) and `path` modules for interacting with the file system.  While manually implementing recursion with these modules can be more verbose, it provides greater control and a deeper understanding of the underlying processes.

Here's how to do it:

```javascript
const fs = require('fs').promises; // Use promises for cleaner async/await
const path = require('path');

async function copyRecursive(source, destination) {
  try {
    // Create the destination directory if it doesn't exist
    await fs.mkdir(destination, { recursive: true });

    // Read the contents of the source directory
    const entries = await fs.readdir(source, { withFileTypes: true });

    for (const entry of entries) {
      const sourcePath = path.join(source, entry.name);
      const destinationPath = path.join(destination, entry.name);

      if (entry.isDirectory()) {
        // Recursively copy subdirectory
        await copyRecursive(sourcePath, destinationPath);
      } else {
        // Copy file
        await fs.copyFile(sourcePath, destinationPath, fs.constants.COPYFILE_FICLONE); // Use COPYFILE_FICLONE to copy data efficiently, if supported
        console.log(`Copied: ${sourcePath} to ${destinationPath}`);
      }
    }

    console.log(`Folder copied successfully from ${source} to ${destination}`);
  } catch (err) {
    console.error(`Error copying folder: ${err}`);
    throw err; // Re-throw the error to be handled by the caller
  }
}

// Example usage
const sourceFolder = './source_folder'; // Replace with your source folder path
const destinationFolder = './destination_folder'; // Replace with your destination folder path

copyRecursive(sourceFolder, destinationFolder)
  .then(() => console.log('Copy operation completed.'))
  .catch(err => console.error('Copy operation failed:', err));

// Create dummy directories and files for demonstration:
async function createDummyFiles(sourceFolder) {
    await fs.mkdir(path.join(sourceFolder, 'subdir1'), {recursive: true});
    await fs.mkdir(path.join(sourceFolder, 'subdir2'), {recursive: true});
    await fs.writeFile(path.join(sourceFolder, 'file1.txt'), 'This is file1', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir1', 'file2.txt'), 'This is file2', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir2', 'file3.txt'), 'This is file3', 'utf8');

}

createDummyFiles(sourceFolder);
```

**Explanation:**

1.  **Import Modules:**  `fs.promises` is used for asynchronous file system operations using promises, and `path` is used for manipulating file paths.
2.  **`copyRecursive(source, destination)` Function:** This function recursively copies files and directories from the `source` to the `destination`.
3.  **Create Destination Directory:**  `fs.mkdir(destination, { recursive: true })` creates the destination directory, including any necessary parent directories.  The `recursive: true` option ensures that parent directories are created if they don't exist.
4.  **Read Directory Contents:**  `fs.readdir(source, { withFileTypes: true })` reads the contents of the source directory.  `withFileTypes: true` returns `fs.Dirent` objects, which provide information about the file type (file, directory, etc.) directly, avoiding the need for subsequent `fs.stat` calls.
5.  **Iterate Through Entries:** The code iterates through each entry (file or directory) in the source directory.
6.  **Construct Paths:** `path.join(source, entry.name)` and `path.join(destination, entry.name)` create the full paths for the source and destination files/directories.
7.  **Check Entry Type:**  `entry.isDirectory()` checks if the current entry is a directory.
8.  **Recursive Call:** If the entry is a directory, the `copyRecursive()` function is called recursively to copy the subdirectory.
9.  **Copy File:** If the entry is a file, `fs.copyFile(sourcePath, destinationPath, fs.constants.COPYFILE_FICLONE)` copies the file from the source to the destination. `fs.constants.COPYFILE_FICLONE` attempts to create a copy-on-write clone of the file, which is more efficient if supported by the file system. If not supported, it falls back to a regular copy.
10. **Error Handling:** The `try...catch` block handles potential errors during the copy process.  The `throw err;` statement re-throws the error so that the caller can handle it.
11. **Example Usage:**  The code demonstrates how to use the `copyRecursive()` function with sample source and destination folder paths.  **Remember to replace these with your actual paths.**
12. **Create Dummy Files:** `createDummyFiles` creates some files and directories so you don't have to.  Remove this code when you're not testing!

**Advantages:**

*   **No External Dependencies:**  Uses only built-in Node.js modules.
*   **Fine-Grained Control:**  Provides complete control over the copy process.

**Disadvantages:**

*   **More Code:** Requires more code compared to using external libraries.
*   **Error Handling:** Requires manual error handling.

## Method 2: Using `fs-extra` Library

The `fs-extra` library provides enhanced file system functionalities, including simplified recursive copy operations. It builds on top of the `fs` module and offers convenience methods for common tasks.

First, install the library:

```bash
npm install fs-extra
```

Then, use it as follows:

```javascript
const fs = require('fs-extra');
const path = require('path');

async function copyRecursiveFsExtra(source, destination) {
  try {
    await fs.copy(source, destination, { overwrite: true,  recursive: true }); // overwrite existing files, if they exist
    console.log(`Folder copied successfully from ${source} to ${destination}`);
  } catch (err) {
    console.error(`Error copying folder: ${err}`);
  }
}

// Example usage
const sourceFolder = './source_folder'; // Replace with your source folder path
const destinationFolder = './destination_folder'; // Replace with your destination folder path

copyRecursiveFsExtra(sourceFolder, destinationFolder);

// Create dummy directories and files for demonstration:
async function createDummyFiles(sourceFolder) {
    await fs.ensureDir(path.join(sourceFolder, 'subdir1'));
    await fs.ensureDir(path.join(sourceFolder, 'subdir2'));
    await fs.writeFile(path.join(sourceFolder, 'file1.txt'), 'This is file1', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir1', 'file2.txt'), 'This is file2', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir2', 'file3.txt'), 'This is file3', 'utf8');

}

createDummyFiles(sourceFolder);
```

**Explanation:**

1.  **Import `fs-extra`:**  `const fs = require('fs-extra');` imports the `fs-extra` library.
2.  **`fs.copy(source, destination, options)`:** This function copies the entire directory structure from `source` to `destination`.
    *   `overwrite: true` allows overwriting existing files in the destination.  If set to `false` and the destination file already exists, an error will be thrown.
    *   `recursive: true` ensures that subdirectories are copied recursively.  This is the default behavior, but it's good practice to explicitly include it.  Also note that `recursive: true` is supported starting Node.js 12.9.0.
3.  **Error Handling:** The `try...catch` block handles potential errors during the copy process.
4. **Use `fs.ensureDir`:** `fs.ensureDir` is used to ensure the directory exists. It creates the directory if it doesn't.

**Advantages:**

*   **Simpler Code:**  Reduces the amount of code required.
*   **Error Handling:** `fs-extra` handles many common errors internally.
*   **Convenience Methods:** Provides other useful file system functions beyond copying.

**Disadvantages:**

*   **External Dependency:** Requires installing an external library.
*   **Less Control:**  Provides less fine-grained control over the copy process compared to using the built-in `fs` module directly.

## Method 3: Using `cp` command line utility via `child_process`

You can leverage the `cp` command line utility (available on most Unix-like systems) through Node.js's `child_process` module. This can be a very efficient option, especially for large folder copies, as it utilizes the system's native copy mechanisms.

```javascript
const { exec } = require('child_process');
const path = require('path');

async function copyRecursiveCp(source, destination) {
  return new Promise((resolve, reject) => {
    exec(`cp -r ${source} ${destination}`, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error copying folder: ${error}`);
        reject(error);
        return;
      }
      console.log(`Folder copied successfully from ${source} to ${destination}`);
      resolve();
    });
  });
}

// Example usage
const sourceFolder = './source_folder'; // Replace with your source folder path
const destinationFolder = './destination_folder'; // Replace with your destination folder path

copyRecursiveCp(sourceFolder, destinationFolder)
  .then(() => console.log('Copy operation completed.'))
  .catch(err => console.error('Copy operation failed:', err));


// Create dummy directories and files for demonstration:
const fs = require('fs').promises;
async function createDummyFiles(sourceFolder) {
    await fs.mkdir(path.join(sourceFolder, 'subdir1'), {recursive: true});
    await fs.mkdir(path.join(sourceFolder, 'subdir2'), {recursive: true});
    await fs.writeFile(path.join(sourceFolder, 'file1.txt'), 'This is file1', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir1', 'file2.txt'), 'This is file2', 'utf8');
    await fs.writeFile(path.join(sourceFolder, 'subdir2', 'file3.txt'), 'This is file3', 'utf8');

}

createDummyFiles(sourceFolder);
```

**Explanation:**

1.  **Import `exec`:** `const { exec } = require('child_process');` imports the `exec` function for executing shell commands.
2.  **`copyRecursiveCp(source, destination)` Function:** This function wraps the `cp` command execution in a Promise for asynchronous handling.
3.  **`exec(\`cp -r ${source} ${destination}\`)`:**  Executes the `cp -r` command.  The `-r` option ensures recursive copying.  **Important:**  Be extremely cautious about using user-provided input directly in shell commands to prevent command injection vulnerabilities. Sanitize input carefully!
4.  **Error Handling:** The callback function handles the result of the command execution. If an error occurs, it's logged and the Promise is rejected.  Otherwise, a success message is logged, and the Promise is resolved.

**Advantages:**

*   **Potentially Faster:**  Leverages the system's optimized `cp` implementation, which can be faster than pure JavaScript implementations for large files or complex directory structures.
*   **Simple Syntax:** Relatively simple to implement.

**Disadvantages:**

*   **Platform Dependency:**  The `cp` command is typically available on Unix-like systems (Linux, macOS). It might not work on Windows without a suitable shell environment (e.g., Git Bash, WSL).
*   **Security Risk:**  Requires careful handling of input to prevent command injection vulnerabilities.  Avoid using user-supplied paths directly in the command.
*   **Less Control:** Provides less direct control over the copying process than using the `fs` module or `fs-extra`.
*   **No Progress Reporting:** Difficult to track the progress of the copy operation.

## Choosing the Right Method

The best method for recursively copying folders in Node.js depends on your specific requirements and constraints:

*   **For Maximum Control and No Dependencies:**  Use the built-in `fs` and `path` modules. This gives you complete control over the process, but requires more code.
*   **For Simplicity and Convenience:**  Use the `fs-extra` library. This reduces the amount of code and provides convenient error handling.
*   **For Potentially Faster Copies on Unix-like Systems:**  Use the `cp` command via the `child_process` module.  Be aware of the platform dependency and security risks.  **Sanitize input!**

Remember to handle errors appropriately in all cases to ensure robust and reliable folder copying. Consider using a progress bar library if you need to provide feedback to the user during the copy operation.

This guide provides a comprehensive overview of how to recursively copy folders in Node.js.  Choose the method that best suits your needs and enjoy the power and flexibility of Node.js file system operations.