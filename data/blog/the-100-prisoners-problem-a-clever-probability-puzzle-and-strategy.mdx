---
title: 'The 100 Prisoners Problem: A Clever Probability Puzzle & Strategy'
date: '2024-10-26'
lastmod: '2024-10-27'
tags: ['probability', 'puzzle', 'mathematics', 'strategy', 'algorithms', 'logic', 'coding', 'optimization']
draft: false
summary: 'Explore the fascinating 100 Prisoners Problem: a counterintuitive probability puzzle with a surprisingly effective strategy. Learn the optimal solution and even see a Python simulation!'
authors: ['default']
---

# The 100 Prisoners Problem: A Clever Probability Puzzle & Strategy

The 100 Prisoners Problem is a classic probability puzzle that challenges our intuition and demonstrates the power of strategic thinking. It highlights how seemingly simple, independent choices can lead to surprising outcomes when considered collectively. Let's dive into the problem, explore the ingenious solution, and even implement a Python simulation to see it in action.

## The Puzzle: 100 Prisoners and a Chest of Drawers

Imagine 100 prisoners, each uniquely numbered from 1 to 100. They are given one last chance to earn their freedom. A warden places each prisoner's number randomly into one of 100 drawers in a chest. Each drawer contains exactly one number.

The rules are as follows:

*   **Individuality:** Each prisoner enters the room with the chest of drawers individually, without communicating with the others.
*   **Limited Attempts:** Each prisoner can open at most 50 drawers.
*   **The Goal:** If *every* prisoner finds their own number within the 50 attempts, all prisoners are freed. If even one prisoner fails to find their number, all prisoners remain incarcerated.
*   **No Communication:** Prisoners cannot leave any information in the drawers or communicate in any way after their turn. They must decide on a strategy *before* the first prisoner enters the room.

**The Question:** What strategy gives the prisoners the highest chance of survival?

## The Naive Approach and Why It Fails

A seemingly straightforward approach is for each prisoner to randomly open 50 drawers. Sounds reasonable, right? Each prisoner has a 50% chance of finding their number. However, the crucial point is that *all* prisoners must succeed.

Let's calculate the probability of success with this random approach. Each prisoner has a 1/2 (50%) chance of finding their number, and a 1/2 (50%) chance of failing. Since the prisoners act independently, the probability of *all* 100 prisoners succeeding is (1/2)<sup>100</sup>, which is an incredibly tiny number – approximately 0.000000000000000000000000000000000000000000000000000000000000000000000000000000008.

The prisoners are doomed with a random strategy.

## The Counterintuitive Solution: Follow the Chain

Surprisingly, there's a much better strategy that gives the prisoners a significantly higher chance of survival – close to 30%!  Here's the strategy:

1.  **Start with Your Own Number:** Each prisoner begins by opening the drawer labeled with their own number.

2.  **Follow the Chain:** If the drawer contains their own number, they are successful. If not, the drawer will contain another prisoner's number. The prisoner then opens the drawer labeled with that number.

3.  **Repeat:** The prisoner continues this process – opening the drawer labeled with the number they just found – until they find their own number or they have opened 50 drawers.

**Why does this work?**  The key is that this strategy introduces dependence between the prisoners' choices. They are no longer acting independently. If the numbers in the drawers form a long "chain" (a sequence of numbers where each number leads to the next), the strategy will fail.  However, if the longest chain is 50 or shorter, *all* prisoners will find their numbers.

## Mathematical Justification: Cycle Decompositions

The arrangement of numbers in the drawers can be mathematically represented as a permutation. Any permutation can be decomposed into disjoint cycles.  A cycle is a sequence of numbers where each number points to the next, and the last number points back to the first.

For example, if the drawers contained the numbers:

```
Drawer:  1  2  3  4  5  6  7  8  9 10
Number:  4  6  2  1  8  9  3  5 10  7
```

This can be represented as the following cycles:

*   (1 4)  - Drawer 1 contains number 4, and drawer 4 contains number 1.
*   (2 6 9 10 7 3) - Drawer 2 contains number 6, drawer 6 contains number 9, drawer 9 contains number 10, drawer 10 contains number 7, drawer 7 contains number 3, and drawer 3 contains number 2.
*   (5 8) - Drawer 5 contains number 8, and drawer 8 contains number 5.

The key to the prisoners' success is ensuring that the *longest* cycle is no longer than 50.  If any cycle is longer than 50, the prisoners whose numbers are in that cycle will fail.

The probability of success is therefore the probability that a random permutation of 100 elements contains no cycle of length greater than 50. This probability is approximately 31.18%.

## Python Simulation

Let's create a Python simulation to verify this strategy and see it in action.

```python
import random

def simulate_prisoners_problem(num_prisoners=100, max_attempts=50, num_trials=10000):
    """
    Simulates the 100 prisoners problem.

    Args:
        num_prisoners: The number of prisoners.
        max_attempts: The maximum number of drawers each prisoner can open.
        num_trials: The number of simulation runs.

    Returns:
        The success rate (proportion of trials where all prisoners are freed).
    """
    success_count = 0

    for _ in range(num_trials):
        # Generate a random permutation (drawer arrangement)
        drawers = list(range(1, num_prisoners + 1))
        random.shuffle(drawers)

        # Simulate each prisoner's attempt
        all_succeeded = True
        for prisoner_number in range(1, num_prisoners + 1):
            attempts = 0
            current_drawer = prisoner_number

            while attempts < max_attempts:
                attempts += 1
                number_in_drawer = drawers[current_drawer - 1] # Adjust index for 0-based list
                if number_in_drawer == prisoner_number:
                    break  # Prisoner found their number
                else:
                    current_drawer = number_in_drawer

            if attempts == max_attempts:
                all_succeeded = False
                break  # One prisoner failed, so all prisoners fail

        if all_succeeded:
            success_count += 1

    return success_count / num_trials


if __name__ == "__main__":
    success_rate = simulate_prisoners_problem()
    print(f"Simulated Success Rate: {success_rate:.4f}")

```

**Explanation of the Code:**

1.  **`simulate_prisoners_problem` function:**
    *   Takes `num_prisoners`, `max_attempts`, and `num_trials` as input.
    *   Initializes `success_count` to 0.
    *   Iterates `num_trials` times, each representing a complete run of the problem.

2.  **Generating a Random Permutation:**
    *   `drawers = list(range(1, num_prisoners + 1))`: Creates a list of numbers representing the numbers to be placed in the drawers.
    *   `random.shuffle(drawers)`: Randomly shuffles the list, simulating the warden's random placement of numbers in the drawers.  This creates our permutation.

3.  **Simulating Each Prisoner's Attempt:**
    *   The outer loop iterates through each prisoner (`prisoner_number`).
    *   `attempts = 0`: Initializes the attempt counter for the current prisoner.
    *   `current_drawer = prisoner_number`:  The prisoner starts by opening the drawer labeled with their own number.
    *   The `while` loop simulates the prisoner opening drawers until they find their own number or reach the `max_attempts` limit.
    *   `number_in_drawer = drawers[current_drawer - 1]`: Retrieves the number found in the current drawer (remembering that list indices are 0-based).
    *   `if number_in_drawer == prisoner_number:`: Checks if the prisoner found their own number. If so, the loop breaks.
    *   `else: current_drawer = number_in_drawer`: If the prisoner didn't find their number, they update `current_drawer` to the number they just found (following the chain).

4.  **Checking for Overall Success:**
    *   `if attempts == max_attempts:`: If a prisoner reaches the maximum number of attempts without finding their number, `all_succeeded` is set to `False`, and the inner loop breaks.
    *   `if all_succeeded: success_count += 1`: If all prisoners succeeded in finding their number, the `success_count` is incremented.

5.  **Returning the Success Rate:**
    *   `return success_count / num_trials`:  Calculates and returns the success rate.

**How to Run the Code:**

1.  Save the code as a Python file (e.g., `prisoners.py`).
2.  Run the file from your terminal: `python prisoners.py`

The output will show the simulated success rate, which should be around 0.31 (31%).  Try increasing the `num_trials` for more accurate results.

## Key Takeaways

*   The 100 Prisoners Problem demonstrates that seemingly independent choices, when considered collectively, can lead to surprising outcomes.
*   Strategic thinking and introducing dependence between choices can significantly improve the odds of success.
*   The optimal strategy involves following the chain of numbers within the drawers.
*   The probability of success with this strategy is significantly higher than a random approach (around 31% versus near zero).
*   The problem can be mathematically explained using cycle decompositions.
*   Simulations can help verify the theoretical results and provide a more intuitive understanding.

This puzzle is a fun and thought-provoking exercise in probability, logic, and strategic thinking. It also showcases the elegance and power of mathematical concepts like permutations and cycle decompositions. So next time you're facing a seemingly impossible challenge, remember the 100 prisoners and the importance of thinking outside the box (or, in this case, the drawer!).