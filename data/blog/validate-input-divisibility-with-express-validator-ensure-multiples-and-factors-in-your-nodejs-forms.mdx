---
title: "Validate Input Divisibility with Express-Validator: Ensure Multiples and Factors in Your Node.js Forms"
date: '2024-10-27'
lastmod: '2024-10-27'
tags: ['express-validator', 'nodejs', 'validation', 'form validation', 'input validation', 'divisibility', 'multiples', 'factors']
draft: false
summary: "Learn how to effectively use Express-Validator in Node.js to validate if user input is divisible by a specific number. This ensures data integrity and improves the reliability of your applications by confirming that numerical inputs are multiples or factors as required."
authors: ['default']
---

# Validate Input Divisibility with Express-Validator: Ensure Multiples and Factors in Your Node.js Forms

Ensuring the integrity of user input is crucial for any robust web application. When dealing with numerical data, you might need to guarantee that a number is a multiple of another number (divisible by it) before processing it. This requirement frequently arises in scenarios such as:

*   Validating age (is it a multiple of 5 for specific discount eligibility?)
*   Verifying quantity (must be a multiple of the packaging size)
*   Checking order amounts (should be divisible by the price of a single item)

Express-Validator, a popular middleware for Express.js, provides a flexible and powerful way to handle such validations.  This comprehensive guide will walk you through using Express-Validator to validate if an input field is divisible by a specific number in your Node.js applications. We'll cover the fundamental concepts, provide practical code examples, and discuss best practices.

## What is Express-Validator?

Express-Validator is a wrapper for [validator.js](https://github.com/validatorjs/validator.js), a rich library of string validators and sanitizers. It seamlessly integrates with Express.js, allowing you to easily validate and sanitize request data, such as parameters, query strings, headers, and request body.

## Setting Up Your Project

Before diving into the code, let's ensure you have a basic Node.js project set up with Express.js and Express-Validator installed.

1.  **Create a Project Directory:**

    ```bash
    mkdir express-validator-divisibility
    cd express-validator-divisibility
    npm init -y
    ```

2.  **Install Dependencies:**

    ```bash
    npm install express express-validator body-parser
    ```

3.  **Create `app.js`:**

    ```bash
    touch app.js
    ```

## Implementing Divisibility Validation with Express-Validator

While Express-Validator doesn't offer a built-in validator specifically for divisibility, we can easily achieve this using the `custom()` validator.  `custom()` allows us to define our own validation logic.

Here's the basic structure of our `app.js` file:

```javascript
const express = require('express');
const { body, validationResult } = require('express-validator');
const bodyParser = require('body-parser');

const app = express();
const port = 3000;

app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

// ... (Validation route will go here) ...

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});
```

Now, let's add a route with validation that checks if the `quantity` field is divisible by `5`.

```javascript
app.post('/order', [
  body('quantity')
    .isInt({min: 1}) // Ensure it's a positive integer
    .withMessage('Quantity must be a positive integer.')
    .custom((value) => {
      if (value % 5 !== 0) {
        throw new Error('Quantity must be divisible by 5.');
      }
      return true;
    }),
  body('product_id').isInt({min:1}).withMessage('Product ID must be a positive integer')
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  // Process the order
  const quantity = req.body.quantity;
  const product_id = req.body.product_id;
  res.send(`Order placed successfully with quantity: ${quantity} and product ID: ${product_id}`);
});
```

**Explanation:**

*   **`app.post('/order', ...)`:**  Defines a POST route at `/order` that handles order placement requests.
*   **`body('quantity')`:**  Specifies that we're validating the `quantity` field from the request body.
*   **`.isInt({min: 1})`:**  Uses the built-in `isInt()` validator to ensure the `quantity` is an integer greater than or equal to 1.  This is important to prevent issues later on.
*   **`.withMessage('Quantity must be a positive integer.')`:**  Sets a custom error message if the `isInt()` validation fails.
*   **`.custom((value) => { ... })`:**  This is where the magic happens. We use the `custom()` validator to define our divisibility check.
    *   **`value`:**  Represents the value of the `quantity` field.
    *   **`if (value % 5 !== 0)`:**  Checks if the remainder of `value` divided by `5` is not equal to `0`.  If it's not `0`, the number is not divisible by `5`.
    *   **`throw new Error('Quantity must be divisible by 5.');`:**  If the validation fails, we throw an error with a descriptive message.
    *   **`return true;`:**  If the validation passes (the number *is* divisible by 5), we return `true` to indicate success.
*   **`validationResult(req)`:**  Collects any validation errors that occurred during the validation chain.
*   **`if (!errors.isEmpty()) { ... }`:**  Checks if there are any validation errors. If so, it sends a 400 (Bad Request) response with an array of error messages.
*   **`res.send(...)`:**  If the validation passes, it processes the order and sends a success message.

## Testing the Validation

You can test this code using tools like Postman or `curl`.  Here's a `curl` example:

**Valid Request (Quantity is divisible by 5):**

```bash
curl -X POST -H "Content-Type: application/json" -d '{"quantity": 15, "product_id": 123}' http://localhost:3000/order
```

This will return:

```
Order placed successfully with quantity: 15 and product ID: 123
```

**Invalid Request (Quantity is not divisible by 5):**

```bash
curl -X POST -H "Content-Type: application/json" -d '{"quantity": 12, "product_id": 123}' http://localhost:3000/order
```

This will return a 400 error:

```json
{
  "errors": [
    {
      "msg": "Quantity must be divisible by 5.",
      "param": "quantity",
      "location": "body"
    }
  ]
}
```

**Invalid Request (Quantity is not an integer):**

```bash
curl -X POST -H "Content-Type: application/json" -d '{"quantity": "abc", "product_id": 123}' http://localhost:3000/order
```

This will return a 400 error:

```json
{
    "errors": [
        {
            "msg": "Quantity must be a positive integer.",
            "param": "quantity",
            "location": "body"
        }
    ]
}
```

##  Customizing the Divisor

The beauty of using the `custom()` validator is its flexibility. You can easily change the divisor based on configuration or user input.

**Example:  Making the Divisor Configurable**

Let's say you want to allow different products to have different quantity requirements. You can pass the divisor as part of the request or retrieve it from a database.

```javascript
app.post('/order/:product_id', [
  body('quantity')
    .isInt({min: 1})
    .withMessage('Quantity must be a positive integer.')
    .custom((value, { req }) => {
      const productId = req.params.product_id;
      // In a real application, you would fetch the divisor from a database
      // based on the product ID. For demonstration purposes, we'll use a simple object.
      const productDivisors = {
        '123': 5,  // Product 123 requires quantities divisible by 5
        '456': 10, // Product 456 requires quantities divisible by 10
        '789': 3   // Product 789 requires quantities divisible by 3
      };

      const divisor = productDivisors[productId] || 1; // Default to 1 if product not found
      if (value % divisor !== 0) {
        throw new Error(`Quantity must be divisible by ${divisor} for this product.`);
      }
      return true;
    }),
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const quantity = req.body.quantity;
  const productId = req.params.product_id;

  res.send(`Order placed successfully for product ID: ${productId} with quantity: ${quantity}`);
});
```

**Key Changes:**

*   **`/order/:product_id`:**  The route now includes a `product_id` parameter.
*   **`custom((value, { req }) => { ... })`:** The `custom` validator function now receives a second argument, `{ req }`, which allows access to the request object.
*   **`req.params.product_id`:** We retrieve the `product_id` from the request parameters.
*   **`productDivisors`:**  This is a placeholder for fetching the divisor from a database or configuration.  In a real-world scenario, you'd replace this with a database query.
*   **`divisor = productDivisors[productId] || 1;`:**  Retrieves the divisor for the given product. If the product isn't found, it defaults to `1`.
*   **`throw new Error(\`Quantity must be divisible by ${divisor} for this product.\`);`:**  The error message now includes the divisor value.

**Testing with Configurable Divisors:**

```bash
# Valid: Quantity 20 is divisible by 10 for product 456
curl -X POST -H "Content-Type: application/json" -d '{"quantity": 20}' http://localhost:3000/order/456

# Invalid: Quantity 12 is NOT divisible by 10 for product 456
curl -X POST -H "Content-Type: application/json" -d '{"quantity": 12}' http://localhost:3000/order/456
```

## Best Practices

*   **Sanitize Inputs:** Before validating, sanitize the input using Express-Validator's sanitization methods (e.g., `toInt()`, `trim()`) to prevent unexpected behavior.
*   **Provide Clear Error Messages:**  Descriptive error messages help users understand what went wrong and how to fix it.
*   **Handle Edge Cases:** Consider potential edge cases, such as negative numbers, zero values, and non-integer inputs, and add appropriate validation rules.
*   **Centralize Validation Logic:**  For more complex applications, create separate modules or functions for your validation logic to keep your routes clean and organized.
*   **Consider Asynchronous Validation:** If you need to perform asynchronous operations during validation (e.g., checking against a database), use the `custom()` validator with an `async` function.

## Advanced Techniques

**Asynchronous Validation with Database Lookup:**

Let's imagine you need to check the divisor dynamically against a database based on the `product_id`.

```javascript
const { body, validationResult } = require('express-validator');
const express = require('express');
const app = express();
const port = 3000;

// Mock database function (replace with your actual database call)
async function getDivisorForProduct(productId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const productDivisors = {
                '123': 5,
                '456': 10,
                '789': 3
            };
            resolve(productDivisors[productId] || null);
        }, 50); // Simulate a database delay
    });
}

app.post('/order/:product_id', [
    body('quantity')
        .isInt({ min: 1 })
        .withMessage('Quantity must be a positive integer.')
        .custom(async (value, { req }) => {
            const productId = req.params.product_id;
            const divisor = await getDivisorForProduct(productId);

            if (!divisor) {
                // if divisor is null it means the product doesn't exist, or maybe we can set default to 1, depends on the requirement.
                throw new Error('Product not found.');  //Or, maybe set `divisor=1` for default behavior
            }

            if (value % divisor !== 0) {
                throw new Error(`Quantity must be divisible by ${divisor} for product ${productId}.`);
            }
            return true;
        })
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const quantity = req.body.quantity;
    const productId = req.params.product_id;

    res.send(`Order placed successfully for product ID: ${productId} with quantity: ${quantity}`);
});

app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});
```

**Explanation of Asynchronous Validation:**

1.  **`async function getDivisorForProduct(productId)`:**  This asynchronous function simulates fetching the divisor from a database. It uses `setTimeout` to mimic a database query delay. In a real application, you'd replace this with your actual database interaction code.

2.  **`custom(async (value, { req }) => { ... })`:** The `custom()` validator function is now declared as `async`.

3.  **`const divisor = await getDivisorForProduct(productId);`:**  We use `await` to wait for the `getDivisorForProduct` function to resolve before proceeding with the validation. This ensures that the divisor is available before we perform the divisibility check.

4.  **Error Handling:**  We included error handling for the case where the `divisor` is `null` (e.g., the product is not found in the database).  You can customize this behavior based on your application's requirements.

## Conclusion

This guide demonstrates how to effectively validate input divisibility using Express-Validator in your Node.js applications. By leveraging the `custom()` validator and asynchronous techniques, you can implement flexible and robust validation logic to ensure the integrity of your numerical data. Remember to sanitize inputs, provide clear error messages, and handle edge cases to create a reliable and user-friendly experience.  By implementing these validations, you can improve the reliability and security of your Node.js web applications.