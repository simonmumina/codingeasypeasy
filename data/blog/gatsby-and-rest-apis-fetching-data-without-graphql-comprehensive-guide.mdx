---
title: 'Gatsby and REST APIs: Fetching Data Without GraphQL (Comprehensive Guide)'
date: '2024-10-26'
lastmod: '2024-10-27'
tags: ['gatsby', 'rest api', 'data fetching', 'javascript', 'react', 'headless cms']
draft: false
summary: 'Learn how to seamlessly integrate REST APIs into your Gatsby project without using GraphQL. This guide provides practical examples and best practices for fetching and displaying data from any RESTful endpoint.'
authors: ['default']
---

# Gatsby and REST APIs: Fetching Data Without GraphQL (Comprehensive Guide)

Gatsby is a powerful static site generator that's often associated with GraphQL. While GraphQL is Gatsby's preferred method for data fetching, it's entirely possible (and often necessary) to work with REST APIs directly. This is particularly useful when integrating with existing APIs or headless CMS solutions that don't offer a GraphQL endpoint. This guide will walk you through the process of fetching data from REST APIs in Gatsby, offering practical examples and best practices.

## Why Use REST APIs with Gatsby?

While GraphQL offers numerous benefits, such as efficient data fetching and schema typing, there are valid reasons to opt for REST APIs:

- **Existing APIs:** You might be working with a legacy API or a third-party service that only exposes a RESTful interface.
- **Headless CMS:** Some headless CMS options offer robust REST APIs but lack GraphQL support.
- **Simplicity:** For smaller projects or simple data requirements, REST APIs can be easier to implement than setting up a GraphQL layer.
- **Learning Curve:** Bypassing GraphQL initially can lower the entry barrier for new Gatsby developers.

## Project Setup

Before we dive into code, let's set up a basic Gatsby project. If you already have one, you can skip this step.

```plaintext
npm install -g gatsby-cli
gatsby new gatsby-rest-api-example
cd gatsby-rest-api-example
```

This creates a new Gatsby project named `gatsby-rest-api-example`.

## The Core Concepts

Fetching data from REST APIs in Gatsby involves these key steps:

1.  **Fetching the Data:** Using `fetch` or a library like `axios` to retrieve data from the API endpoint.
2.  **Processing the Data:** Transforming the data into a format suitable for your Gatsby components.
3.  **Creating Pages or Components:** Integrating the fetched data into your pages or reusable components.

We'll explore these steps using the `gatsby-node.js` file and component files.

## Fetching Data in `gatsby-node.js`

The `gatsby-node.js` file is where you have complete control over Gatsby's build process. It's the perfect place to fetch data from APIs and create pages programmatically.

### Example API: JSONPlaceholder

We'll use the JSONPlaceholder API (https://jsonplaceholder.typicode.com/) for our examples. It provides mock data for testing purposes.

### 1. Install `node-fetch`

Since Gatsby uses Node.js during its build process, we can use Node's built-in `fetch` API, or install the `node-fetch` package for broader compatibility (especially in older Node versions).

```plaintext
npm install node-fetch
```

### 2. Fetch the Data in `gatsby-node.js`

Open `gatsby-node.js` and add the following code:

```plaintext
const fetch = require('node-fetch')

exports.createPages = async ({ actions }) => {
  const { createPage } = actions

  const response = await fetch('https://jsonplaceholder.typicode.com/posts')
  const posts = await response.json()

  posts.forEach((post) => {
    createPage({
      path: `/post/${post.id}`,
      component: require.resolve('./src/templates/post.js'),
      context: {
        id: post.id,
      },
    })
  })
}
```

**Explanation:**

- **`require('node-fetch')`:** Imports the `node-fetch` library.
- **`exports.createPages = async ({ actions }) => { ... }`:** This function runs during the Gatsby build process. It gives us access to the `createPage` action, which allows us to programmatically create pages.
- **`await fetch('https://jsonplaceholder.typicode.com/posts')`:** Fetches data from the JSONPlaceholder API. The `await` keyword ensures that the code waits for the response before proceeding.
- **`const posts = await response.json()`:** Parses the response body as JSON.
- **`posts.forEach(post => { ... })`:** Iterates over each post in the `posts` array.
- **`createPage({ ... })`:** Creates a new page for each post.
  - **`path: \`/post/${post.id}\``:** Defines the URL for the new page (e.g., `/post/1`, `/post/2`, etc.).
  - **`component: require.resolve('./src/templates/post.js')`:** Specifies the component that will render the page. We'll create this template file next.
  - **`context: { id: post.id }`:** Passes data to the component through the `context` object. We're passing the `id` of the post, which we'll use to fetch the specific post's data in the component.

### 3. Create a Post Template (`src/templates/post.js`)

Create a new directory `src/templates` and create a file named `post.js` inside it. Add the following code:

```jsx
import React from 'react'
import { graphql } from 'gatsby'

const Post = ({ data }) => {
  const post = data.placeholderPost

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  )
}

export const query = graphql`
  query ($id: Int!) {
    placeholderPost(id: { eq: $id }) {
      id
      title
      body
    }
  }
`

export default Post
```

**Explanation:**

- **`import React from 'react';`:** Imports the React library.
- **`const Post = ({ data }) => { ... }`:** Defines a functional component named `Post`. The `data` prop contains the data fetched by the GraphQL query.
- **`const post = data.placeholderPost;`:** Extracts the post data from the `data` prop.
- **`return ( ... )`:** Returns the JSX that will be rendered. It displays the title and body of the post.
- **`export const query = graphql\` ... \``:** Defines a GraphQL query. This query is automatically executed by Gatsby when the component is rendered.
  - **`query($id: Int!) { ... }`:** Defines a query with a variable named `$id`, which is an integer and is required. This ID will be passed from the `context` in `gatsby-node.js`.
  - **`placeholderPost(id: { eq: $id }) { ... }`:** Filters the data to retrieve the post with the specified ID. This example uses a plugin that simulates the result of a rest api using schema customization. We will see how to implement the fetching and data manipulation of a rest api without graphql later.
  - **`id`, `title`, `body`:** Specifies the fields to retrieve from the post.
- **`export default Post;`:** Exports the `Post` component.

**Important Note:** This example is using a GraphQL query within the template. While our goal is to use REST APIs without GraphQL, we need a way to pass the fetched data to the template. The GraphQL query here uses a simulated `placeholderPost` node provided by the dummy data to illustrate how data is passed to a template. The next section will address how to completely eliminate the GraphQL query.

### 4. Simulate Rest API data with schema customization

To test the GraphQL query on the post template we need to use schema customization. First install the following packages:

```plaintext
npm install gatsby-source-filesystem
npm install gatsby-transformer-json
```

Add the plugins to `gatsby-config.js`:

```plaintext
module.exports = {
  plugins: [`gatsby-source-filesystem`, `gatsby-transformer-json`],
}
```

Now configure your `gatsby-node.js` file.

```plaintext
const fetch = require('node-fetch')

exports.sourceNodes = async ({ actions, createNodeId, createContentDigest }) => {
  const { createNode } = actions

  const response = await fetch('https://jsonplaceholder.typicode.com/posts')
  const data = await response.json()

  data.forEach((post) => {
    const nodeMeta = {
      id: createNodeId(`placeholder-post-${post.id}`),
      parent: null,
      children: [],
      internal: {
        type: `PlaceholderPost`,
        contentDigest: createContentDigest(post),
      },
    }

    const node = Object.assign({}, post, nodeMeta)
    createNode(node)
  })
}

exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type PlaceholderPost implements Node {
      userId: Int
      id: Int!
      title: String
      body: String
    }
  `
  createTypes(typeDefs)
}

exports.createPages = async ({ graphql, actions }) => {
  const { createPage } = actions
  const result = await graphql(`
    query {
      allPlaceholderPost {
        nodes {
          id
        }
      }
    }
  `)

  result.data.allPlaceholderPost.nodes.forEach((node) => {
    createPage({
      path: `/post/${node.id.split('-').pop()}`, // Extract the post ID
      component: require.resolve('./src/templates/post.js'),
      context: {
        id: parseInt(node.id.split('-').pop()), // Parse ID to integer
      },
    })
  })
}
```

**Explanation:**

- **`sourceNodes`:** This function is used to create nodes from external data sources. In this case, it fetches data from the JSONPlaceholder API and creates `PlaceholderPost` nodes for each post.
- **`createSchemaCustomization`:** This function is used to define the schema for the `PlaceholderPost` type. This allows Gatsby to understand the structure of the data and create GraphQL queries for it.
- **`createPages`:** The GraphQL query now fetches all `PlaceholderPost` nodes, and the `createPage` function creates a page for each node, passing the post ID in the `context`.

### 5. Run the Development Server

```plaintext
gatsby develop
```

Open your browser and navigate to `http://localhost:8000/post/1` (or any other post ID). You should see the title and body of the corresponding post.

## Fetching Data Directly in Components (Without GraphQL)

Now, let's remove the GraphQL query from the `post.js` template and fetch the data directly within the component using `useEffect`. This demonstrates how to completely avoid GraphQL for REST API integration.

### 1. Modify the Post Template (`src/templates/post.js`)

Update the `post.js` file with the following code:

```jsx
import React, { useState, useEffect } from 'react'

const Post = ({ pageContext }) => {
  const [post, setPost] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    const fetchPost = async () => {
      try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${pageContext.id}`)
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`)
        }
        const data = await response.json()
        setPost(data)
        setLoading(false)
      } catch (error) {
        setError(error)
        setLoading(false)
      }
    }

    fetchPost()
  }, [pageContext.id]) // Dependency array ensures useEffect only runs when pageContext.id changes

  if (loading) {
    return <p>Loading...</p>
  }

  if (error) {
    return <p>Error: {error.message}</p>
  }

  if (!post) {
    return <p>No post found.</p>
  }

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  )
}

export default Post
```

**Explanation:**

- **`import React, { useState, useEffect } from 'react';`:** Imports `useState` and `useEffect` hooks.
- **`const [post, setPost] = useState(null);`:** Creates a state variable `post` to store the post data, initialized to `null`.
- **`const [loading, setLoading] = useState(true);`:** Creates a state variable `loading` to indicate whether the data is still being fetched, initialized to `true`.
- **`const [error, setError] = useState(null);`:** Creates a state variable `error` to store any errors that occur during the fetch, initialized to `null`.
- **`useEffect(() => { ... }, [pageContext.id]);`:** Uses the `useEffect` hook to perform the data fetching.
  - **`const fetchPost = async () => { ... }`:** Defines an asynchronous function to fetch the post data.
  - **`const response = await fetch(\`https://jsonplaceholder.typicode.com/posts/${pageContext.id}\`)`:** Fetches data from the API endpoint, using the `id` passed in through `pageContext` from `gatsby-node.js`.
  - **`const data = await response.json()`:** Parses the response body as JSON.
  - **`setPost(data)`:** Updates the `post` state with the fetched data.
  - **`setLoading(false)`:** Sets the `loading` state to `false`.
  - **`setError(error)`:** Catch any errors and update error status.
  - **`[pageContext.id]`:** The dependency array. `useEffect` will only run when the value of `pageContext.id` changes. This is crucial to prevent infinite loops and ensure that the data is only fetched when the page is first loaded or when the `id` changes.
- **Conditional Rendering:** The component now renders different content based on the `loading`, `error`, and `post` states:
  - **`if (loading) { return <p>Loading...</p>; }`:** Displays a loading message while the data is being fetched.
  - **`if (error) { return <p>Error: {error.message}</p>; }`:** Displays an error message if an error occurred during the fetch.
  - **`if (!post) { return <p>No post found.</p>; }`:** Displays a message if no post data was found.
- **`return ( ... )`:** Renders the post title and body if the data is successfully fetched.

### 2. Remove the GraphQL Query

Since we're now fetching data directly in the component, you can remove the `graphql` query export from `src/templates/post.js`. The file should now look like this:

```jsx
import React, { useState, useEffect } from 'react'

const Post = ({ pageContext }) => {
  const [post, setPost] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    const fetchPost = async () => {
      try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${pageContext.id}`)
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`)
        }
        const data = await response.json()
        setPost(data)
        setLoading(false)
      } catch (error) {
        setError(error)
        setLoading(false)
      }
    }

    fetchPost()
  }, [pageContext.id])

  if (loading) {
    return <p>Loading...</p>
  }

  if (error) {
    return <p>Error: {error.message}</p>
  }

  if (!post) {
    return <p>No post found.</p>
  }

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  )
}

export default Post
```

### 3. Run the Development Server

```plaintext
gatsby develop
```

Open your browser and navigate to `http://localhost:8000/post/1` (or any other post ID). You should see the title and body of the corresponding post, fetched directly from the REST API without using GraphQL.

## Best Practices

Here are some best practices to keep in mind when working with REST APIs in Gatsby:

- **Environment Variables:** Store API keys and other sensitive information in environment variables (using a library like `dotenv`) to avoid exposing them in your code.
- **Error Handling:** Implement robust error handling to gracefully handle API failures and provide informative error messages to the user.
- **Loading States:** Use loading indicators to provide feedback to the user while data is being fetched.
- **Caching:** Consider caching API responses to improve performance and reduce API requests. You can use the Gatsby cache APIs for this, or a dedicated caching library.
- **Data Transformation:** Transform the data into a format that's suitable for your components. This might involve renaming fields, converting data types, or combining data from multiple APIs.
- **Consider using a Custom Hook:** Encapsulate your data fetching logic into a custom hook for better reusability and maintainability.
- **Debouncing/Throttling:** If the API calls are triggered frequently (e.g., on scroll or input changes), consider using debouncing or throttling techniques to reduce the number of requests.

## Example: Using a Custom Hook

To further organize your code, you can create a custom hook to handle the data fetching logic. Create a file named `src/hooks/usePost.js` with the following content:

```plaintext
import { useState, useEffect } from 'react'

const usePost = (postId) => {
  const [post, setPost] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    const fetchPost = async () => {
      try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`)
        }
        const data = await response.json()
        setPost(data)
        setLoading(false)
      } catch (error) {
        setError(error)
        setLoading(false)
      }
    }

    fetchPost()
  }, [postId])

  return { post, loading, error }
}

export default usePost
```

Then, update your `src/templates/post.js` file to use the custom hook:

```jsx
import React from 'react'
import usePost from '../hooks/usePost'

const Post = ({ pageContext }) => {
  const { post, loading, error } = usePost(pageContext.id)

  if (loading) {
    return <p>Loading...</p>
  }

  if (error) {
    return <p>Error: {error.message}</p>
  }

  if (!post) {
    return <p>No post found.</p>
  }

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  )
}

export default Post
```

This makes your component cleaner and separates the data fetching logic into a reusable hook.

## Conclusion

While Gatsby and GraphQL are often used together, this guide demonstrates that integrating with REST APIs directly is a viable and often necessary approach. By using `fetch` and `useEffect`, you can seamlessly fetch and display data from any RESTful endpoint in your Gatsby project. Remember to follow best practices for error handling, loading states, and data transformation to create a robust and user-friendly experience. Happy coding!
