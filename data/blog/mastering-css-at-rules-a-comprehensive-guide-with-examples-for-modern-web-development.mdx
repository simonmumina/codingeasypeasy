---
title: 'Mastering CSS At-Rules: A Comprehensive Guide with Examples for Modern Web Development'
date: '2024-10-27'
lastmod: '2024-10-27'
tags:
  [
    'css',
    'at-rules',
    'web development',
    'responsive design',
    'media queries',
    'font-face',
    'keyframes',
    'supports',
    'container queries',
    'import',
    'charset',
    'namespace',
    'viewport',
    'counter-style',
    'page',
    'position-try',
    'property',
    'layer',
  ]
draft: false
summary: 'Unlock the power of CSS At-Rules! This comprehensive guide explores all CSS at-rules, including media queries, font-face, keyframes, supports, container queries and more, with practical examples to enhance your web design and development skills.'
authors: ['default']
---

# Mastering CSS At-Rules: A Comprehensive Guide with Examples for Modern Web Development

CSS At-rules are powerful statements that instruct the CSS engine on how to behave in certain situations or how to organize and interpret the stylesheet. They provide ways to conditionally apply styles, import external stylesheets, define custom fonts, animations, and more. This guide will delve into each at-rule, providing clear explanations and practical examples to help you leverage their full potential.

## What are CSS At-Rules?

At-rules are denoted by an `@` symbol followed by an identifier (the at-keyword) and then a block of code or a single statement. They can be used to define conditional styles based on media features, import external resources, or define custom animation sequences. Understanding at-rules is crucial for writing maintainable, responsive, and performant CSS.

## Common CSS At-Rules

Let's explore the most commonly used CSS at-rules, each with detailed explanations and code examples:

### 1. `@media`: Responsive Design Powerhouse

The `@media` at-rule is the cornerstone of responsive web design. It allows you to apply different styles based on media features like screen size, orientation, resolution, and more.

**Syntax:**

```plaintext
@media (media-feature) {
  /* CSS rules to apply when the media feature is true */
}
```

**Examples:**

- **Targeting screen size:**

  ```plaintext
  body {
    font-size: 16px;
  }

  @media (max-width: 768px) {
    body {
      font-size: 14px;
    }
  }

  @media (min-width: 992px) {
    body {
      font-size: 18px;
    }
  }
  ```

  This example adjusts the `font-size` of the `body` element based on the screen width.

- **Targeting print styles:**

  ```plaintext
  @media print {
    body {
      font-size: 12px;
      color: black;
    }

    nav {
      display: none; /* Hide navigation in print */
    }
  }
  ```

  This example provides styles specifically for printing, hiding unnecessary elements and adjusting text size and color.

- **Targeting dark mode using `prefers-color-scheme`:**

  ```plaintext
  body {
    background-color: white;
    color: black;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: black;
      color: white;
    }
    a {
      color: lightblue;
    }
  }
  ```

  This allows your site to adapt to the user's preferred color scheme.

### 2. `@font-face`: Custom Fonts Made Easy

The `@font-face` at-rule allows you to embed custom fonts into your webpage, giving you more control over typography.

**Syntax:**

```plaintext
@font-face {
  font-family: 'MyCustomFont';
  src: url('path/to/my-font.woff2') format('woff2'),
       url('path/to/my-font.woff') format('woff');
  font-weight: normal;
  font-style: normal;
}
```

**Explanation:**

- `font-family`: Defines the name you'll use to refer to this font in your CSS.
- `src`: Specifies the URL(s) of the font file(s) and their format(s). Providing multiple formats ensures broader browser compatibility. WOFF2 is generally preferred for modern browsers.
- `font-weight`: Defines the weight (e.g., `normal`, `bold`, `100`, `900`) for which this font should be used.
- `font-style`: Defines the style (e.g., `normal`, `italic`) for which this font should be used.

**Example:**

```plaintext
@font-face {
  font-family: 'Roboto';
  src: url('/fonts/roboto-regular.woff2') format('woff2'),
       url('/fonts/roboto-regular.woff') format('woff');
  font-weight: normal;
  font-style: normal;
}

@font-face {
  font-family: 'Roboto';
  src: url('/fonts/roboto-bold.woff2') format('woff2'),
       url('/fonts/roboto-bold.woff') format('woff');
  font-weight: bold;
  font-style: normal;
}

body {
  font-family: 'Roboto', sans-serif;
}

h1, h2, h3 {
  font-family: 'Roboto', sans-serif;
  font-weight: bold;
}
```

This example defines the "Roboto" font with both regular and bold weights.

### 3. `@keyframes`: Animating Your Website

The `@keyframes` at-rule allows you to define animation sequences in CSS. You specify different keyframes (points in time) with associated styles, and the browser smoothly transitions between them.

**Syntax:**

```plaintext
@keyframes animationName {
  0% {
    /* Styles at the beginning of the animation */
  }
  50% {
    /* Styles at the midpoint of the animation */
  }
  100% {
    /* Styles at the end of the animation */
  }
}
```

**Example:**

```plaintext
@keyframes fadeIn {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.fade-in-element {
  animation: fadeIn 1s ease-in-out;
}
```

This example defines a `fadeIn` animation and applies it to an element with the class `fade-in-element`. The animation lasts 1 second, uses an ease-in-out timing function, and gradually increases the opacity from 0 to 1.

### 4. `@supports`: Feature Detection in CSS

The `@supports` at-rule allows you to conditionally apply styles based on whether the browser supports a specific CSS feature. This enables you to use modern CSS features while providing fallbacks for older browsers.

**Syntax:**

```plaintext
@supports (property: value) {
  /* CSS rules to apply if the browser supports the property: value */
}
```

**Example:**

```plaintext
.grid-container {
  display: flex; /* Fallback for older browsers */
}

@supports (display: grid) {
  .grid-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
  }
}
```

In this example, the `grid-container` will use `display: flex` if the browser doesn't support `display: grid`, providing a basic layout. If `display: grid` is supported, it will use the more advanced grid layout.

You can also use `not` and `or` to create more complex conditions:

```plaintext
@supports not (display: flex) {
  /* Styles to apply if the browser DOES NOT support flexbox */
}

@supports (display: grid) or (display: flex) {
  /* Styles to apply if the browser supports grid OR flexbox */
}
```

### 5. `@container`: Contextual Styling with Container Queries

The `@container` at-rule enables contextual styling based on the size or style of a _parent_ container, rather than the viewport. This provides more flexibility for creating truly responsive components that adapt to their specific context within the layout.

**Syntax:**

First, define a container:

```plaintext
.card-container {
  container: card-area / inline-size;  /* creates a container context named "card-area" based on inline-size (width in LTR) */
}
```

Then, use `@container` to apply styles based on the container's properties:

```plaintext
@container card-area (min-width: 400px) {
  .card {
    flex-direction: row; /* change the card layout if the container is at least 400px wide */
  }
}
```

**Example:**

```html
<div class="card-container">
  <div class="card">
    <img src="image.jpg" alt="Card Image" />
    <h3>Card Title</h3>
    <p>Card description goes here.</p>
  </div>
</div>
```

```plaintext
.card-container {
  container: card-area / inline-size;
  display: inline-block; /*Important: the container needs a defined size somehow*/
  width: 300px;
}

.card {
  display: flex;
  flex-direction: column;
  border: 1px solid #ccc;
  padding: 10px;
}

@container card-area (min-width: 400px) {
  .card {
    flex-direction: row; /* Change to horizontal layout when container is wide enough */
  }

  .card img {
    width: 100px;
    height: 100px;
    margin-right: 10px;
  }
}
```

In this example, the card's layout changes from a column to a row when the `card-container`'s width is at least 400px.

### 6. `@import`: Modular CSS

The `@import` at-rule allows you to import external CSS stylesheets into your current stylesheet. It helps organize your CSS into smaller, manageable files.

**Syntax:**

```plaintext
@import url("path/to/stylesheet.css");
@import "stylesheet.css"; /*shorthand if no special features like supports, etc. are needed */
```

**Example:**

```plaintext
@import url("reset.css");
@import url("variables.css");
@import url("components/buttons.css");

body {
  font-family: sans-serif;
}
```

**Important Considerations for `@import`:**

- **Placement:** `@import` statements _must_ be placed at the very beginning of your CSS file, before any other rules.
- **Performance:** Excessive use of `@import` can negatively impact performance. Browsers must download and parse each imported file, which can add significant overhead. Consider using CSS preprocessors like Sass or Less to compile your styles into a single file, or use module bundlers.

### 7. `@charset`: Specifying Character Encoding

The `@charset` at-rule specifies the character encoding used in the stylesheet. It's crucial for ensuring that special characters are displayed correctly.

**Syntax:**

```plaintext
@charset "UTF-8";
```

**Example:**

```plaintext
@charset "UTF-8"; /*  MUST BE the very first thing in the file! */

body {
  font-family: sans-serif;
}

p::before {
  content: "Â©"; /* Copyright symbol */
}
```

**Best Practices:**

- Always use `UTF-8` encoding, as it's the most widely supported and recommended encoding for web content.
- Place the `@charset` declaration at the very beginning of the CSS file.

### 8. `@namespace`: XML Namespaces in CSS

The `@namespace` at-rule is used to specify an XML namespace to be associated with a CSS stylesheet. This is primarily used when styling XML documents (like SVG or XHTML) using CSS.

**Syntax:**

```plaintext
@namespace prefix "URI";
```

**Example:**

```plaintext
@namespace svg "http://www.w3.org/2000/svg";

svg|rect {
  fill: blue; /* targets rect elements within the SVG namespace */
}
```

This example defines the `svg` namespace and applies a blue fill to all `rect` elements within that namespace. Note the `svg|` prefix used to target elements in that namespace.

### 9. `@viewport`: Controlling the Viewport

The `@viewport` at-rule provides control over the initial scale, zoom, and other properties of the viewport on mobile devices. It's mostly superseded by the `<meta name="viewport">` tag in HTML, but can still be used in some specific contexts.

**Syntax:**

```plaintext
@viewport {
  width: device-width;
  initial-scale: 1.0;
  user-scalable: no;
}
```

**Example:**

```plaintext
@viewport {
  width: device-width;
  zoom: 1.0; /*  deprecated */
}
```

**Recommendation:** Use the `<meta name="viewport">` tag in the `<head>` of your HTML document instead of `@viewport` whenever possible, as it's more widely supported and offers more flexibility. The HTML meta tag equivalent is:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

### 10. `@counter-style`: Defining Custom Counters

The `@counter-style` at-rule allows you to define custom counter styles for use with CSS list-item counters. This gives you fine-grained control over the appearance of numbered lists.

**Syntax:**

```plaintext
@counter-style custom-counter {
  system: additive; /* Specify counter system e.g. symbolic, numeric, additive */
  additive-symbols: 30 'â¤ï¸', 10 'ð', 1 'ð';  /* Additive system symbols */
  suffix: " "; /*  Add a space after the counter */
}
```

**Example:**

```plaintext
@counter-style thumbs {
  system: cyclic;
  symbols: "ð" "ð";
  suffix: " ";
}

ol {
  list-style: thumbs; /* Uses the counter style */
}
```

```html
<ol>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ol>
```

This example creates a custom counter style that uses thumbs-up and thumbs-down emojis for list markers.

### 11. `@page`: Styling Paged Media (Print)

The `@page` at-rule is used to style the overall layout of a document when printed. It allows you to control margins, headers, footers, and other page-related properties.

**Syntax:**

```plaintext
@page {
  size: A4;
  margin: 2cm;

  @top-left {
    content: "Document Title";
  }

  @bottom-right {
    content: "Page " counter(page);
  }
}
```

**Example:**

```plaintext
@page {
  size: letter; /* US Letter size */
  margin: 1in;

  @top-right {
    content: "Company Logo";
  }

  @bottom-center {
    content: "Page " counter(page);
  }
}
```

This example sets the page size to "letter", adds a 1-inch margin, displays "Company Logo" in the top-right corner, and displays the page number in the bottom-center corner.

### 12. `@position-try`: Experimental, Not Recommended for Production

The `@position-try` at-rule is an experimental feature that allows you to specify alternative positioning strategies for elements. It's currently not widely supported and should be avoided in production code.

### 13. `@property`: Defining Custom CSS Properties (Registered Properties)

The `@property` at-rule allows you to register custom CSS properties, giving you more control over their behavior, including type checking, initial values, and inheritance.

**Syntax:**

```plaintext
@property --my-custom-property {
  syntax: '<color>';
  inherits: false;
  initial-value: red;
}
```

**Explanation:**

- `syntax`: Defines the expected type of the property value (e.g., `<color>`, `<number>`, `<length>`).
- `inherits`: Specifies whether the property should inherit from its parent element.
- `initial-value`: Defines the initial value of the property if none is specified.

**Example:**

```plaintext
@property --highlight-color {
  syntax: '<color>';
  inherits: false;
  initial-value: yellow;
}

.highlighted {
  --highlight-color: lightgreen; /* Override the initial value */
  background-color: var(--highlight-color);
}
```

This example registers a custom property called `--highlight-color` and uses it to set the background color of an element.

### 14. `@layer`: Cascade Layers

The `@layer` at-rule allows you to create cascade layers in your CSS. These layers provide explicit control over the order in which CSS rules are applied, regardless of their specificity or source order in the stylesheet. This is very useful in large projects or when using third-party CSS libraries.

**Syntax:**

```plaintext
@layer reset, theme, components, utilities; /*Define the layers and their order */

@layer reset {
  /* Reset styles (normalize.css, etc.) */
}

@layer theme {
  /* Theme-specific styles */
}

@layer components {
  /* Styles for UI components */
}

@layer utilities {
  /* Utility classes (margin, padding, etc.) */
}
```

**Example:**

```plaintext
@layer base, typography, components, utilities;

@layer base {
  body {
    margin: 0;
    font-family: sans-serif;
  }
}

@layer typography {
  h1 {
    font-size: 2em;
    color: darkblue;
  }
}

@layer components {
  .button {
    background-color: blue;
    color: white;
  }
}

@layer utilities {
  .mt-2 {
    margin-top: 0.5rem;
  }
}
```

In this example, the layers are defined as `base`, `typography`, `components`, and `utilities`. Styles within the `base` layer will always take precedence over styles in the `typography` layer, even if the styles in the `typography` layer have higher specificity.

## Conclusion

CSS at-rules provide a robust set of tools for controlling the behavior and organization of your stylesheets. Mastering these at-rules will significantly enhance your ability to create responsive, maintainable, and visually appealing websites. Remember to consider browser compatibility and performance implications when using at-rules, and leverage the power of CSS preprocessors and module bundlers to optimize your workflow.
