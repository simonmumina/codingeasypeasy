---
title: 'Next.js API Routes: A Complete Guide with Examples'
date: '2023-10-27'
lastmod: '2024-10-26'
tags: ['nextjs', 'api routes', 'serverless functions', 'backend', 'javascript', 'node.js', 'vercel']
draft: false
summary: 'Learn how to create dynamic and scalable backend functionality directly within your Next.js application using API routes. This comprehensive guide covers everything from basic setup to advanced techniques with real-world code examples.'
authors: ['default']
---

# Next.js API Routes: A Complete Guide with Examples

Next.js API routes provide a powerful and convenient way to build backend functionality directly within your Next.js application. They are serverless functions that you can use to handle API requests, interact with databases, and perform other server-side operations, all without the need for a separate backend server. This comprehensive guide will walk you through everything you need to know about Next.js API routes, from basic concepts to advanced techniques.

## What are Next.js API Routes?

Think of Next.js API routes as serverless functions defined within your Next.js project. They reside in the `pages/api` directory and are automatically mapped to API endpoints. When a request is made to one of these endpoints, the corresponding function is executed on the server.

Here's why API routes are beneficial:

*   **Backend Within Your Frontend:**  They allow you to create a full-stack application within a single Next.js project.
*   **Serverless Architecture:** API routes are deployed as serverless functions, meaning you don't need to manage servers or infrastructure. Vercel (the creators of Next.js) and Netlify are common platforms for deploying serverless functions.
*   **Simplified Development:** Streamlines the development process by allowing you to work on both frontend and backend within the same codebase.
*   **Scalability:** Serverless functions automatically scale to handle increased traffic, ensuring your application remains responsive.
*   **Security:**  You can keep sensitive data and logic on the server, protecting it from client-side exposure.

## Getting Started: Creating Your First API Route

1.  **Create the `pages/api` directory:** If it doesn't already exist, create a directory named `api` inside your `pages` directory. This is where you'll place your API route files.

2.  **Create an API route file:**  Inside the `pages/api` directory, create a new file (e.g., `hello.js`). This file will contain the code for your API route.

3.  **Define the API handler function:** The core of an API route is the handler function.  This function receives two arguments:

    *   `req` (IncomingMessage): An object containing information about the incoming request, such as headers, query parameters, and request body.  It's Node.js' `http.IncomingMessage` extended with helpers.
    *   `res` (ServerResponse): An object used to send a response back to the client. It's Node.js' `http.ServerResponse`.

Here's a simple example:

```javascript
// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ name: 'John Doe' });
}
```

4.  **Access the API route:** In your browser, navigate to `/api/hello`. You should see a JSON response: `{"name":"John Doe"}`.

**Explanation:**

*   `export default function handler(req, res) { ... }` defines the handler function that will be executed when the API route is accessed.  It's the default export.
*   `res.status(200)` sets the HTTP status code to 200 (OK).
*   `res.json({ name: 'John Doe' })` sends a JSON response with a single property, `name`, set to "John Doe".

## Handling Different HTTP Methods

API routes can handle different HTTP methods (GET, POST, PUT, DELETE, etc.). You can use the `req.method` property to determine which method was used and then execute different logic accordingly.

```javascript
// pages/api/method.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    // Process a GET request
    res.status(200).json({ message: 'This is a GET request' });
  } else if (req.method === 'POST') {
    // Process a POST request
    const data = req.body; // Access the request body
    res.status(201).json({ message: 'This is a POST request', data });
  } else {
    // Handle any other HTTP method
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

**Explanation:**

*   `req.method` contains the HTTP method used for the request (e.g., "GET", "POST", "PUT", "DELETE").
*   We use `if` and `else if` statements to handle different methods.
*   `req.body` contains the data sent in the request body (for POST, PUT, and PATCH requests).  You'll typically need to parse this data as JSON (see the "Parsing Request Bodies" section below).
*   `res.setHeader('Allow', ['GET', 'POST'])` sets the `Allow` header, indicating which methods are allowed for this endpoint.
*   `res.status(405).end(`Method ${req.method} Not Allowed`)` sends a 405 (Method Not Allowed) error.

## Parsing Request Bodies

For POST, PUT, and PATCH requests, you'll often need to parse the request body to access the data sent by the client. Next.js doesn't automatically parse the request body for you, so you need to do it manually.

Here's how to parse JSON request bodies:

```javascript
// pages/api/post.js
export default async function handler(req, res) {
  if (req.method === 'POST') {
    try {
      const data = JSON.parse(req.body); // Parse the JSON string
      console.log("Received Data:", data);
      res.status(201).json({ message: 'Data received', data });
    } catch (error) {
      console.error("Error parsing JSON:", error);
      res.status(400).json({ message: 'Invalid JSON' });
    }
  } else {
    res.status(405).end();
  }
}
```

**Important Note:** While the above code will work in many cases, for production applications, it's highly recommended to use a middleware library like `next-connect` or `micro` which provide built-in body parsing and error handling capabilities. Using these libraries simplifies your API route code and improves its robustness.

Here's an example using `next-connect`:

```bash
npm install next-connect
```

```javascript
// pages/api/post.js
import nextConnect from 'next-connect';

const handler = nextConnect();

handler.use(async (req, res, next) => {
  // Middleware to parse JSON body
  try {
    req.body = JSON.parse(req.body);
    next();
  } catch (error) {
    res.status(400).json({ message: 'Invalid JSON' });
  }
});

handler.post(async (req, res) => {
  const data = req.body;
  console.log("Received Data:", data);
  res.status(201).json({ message: 'Data received', data });
});

export default handler;

export const config = {
  api: {
    bodyParser: false, // Disable the default body parser in Next.js
  },
};
```

**Explanation (using `next-connect`):**

*   We import `nextConnect` to create a middleware handler.
*   We use the `.use()` method to define middleware that parses the JSON body. This middleware will be executed before the POST handler. Note the `bodyParser: false` in the `config` export; this prevents Next.js from trying to parse the body using its built-in mechanism (which would conflict with our custom middleware).
*   The `handler.post()` defines the handler for POST requests.  Now `req.body` will automatically contain the parsed JSON data.
*   Error handling is integrated directly into the middleware.

## Accessing Query Parameters

You can access query parameters from the URL using `req.query`. This is useful for passing data to your API route in GET requests.

```javascript
// pages/api/query.js
export default function handler(req, res) {
  const { name, age } = req.query;

  if (!name || !age) {
    return res.status(400).json({ message: 'Name and age are required parameters' });
  }

  res.status(200).json({ name, age });
}
```

**Example:**

If you visit `/api/query?name=Alice&age=30`, the API route will return:

```json
{
  "name": "Alice",
  "age": "30"
}
```

**Explanation:**

*   `req.query` is an object containing the query parameters from the URL.
*   We destructure `req.query` to extract the `name` and `age` parameters.
*   We check if both `name` and `age` are present.
*   We send a JSON response containing the `name` and `age`.

##  Reading and Writing Cookies

API routes can read and set cookies using the `req.cookies` and `res.setHeader('Set-Cookie', ...)` methods.

```javascript
// pages/api/cookies.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    const myCookie = req.cookies.myCookie || 'No cookie set';
    res.status(200).json({ cookie: myCookie });
  } else if (req.method === 'POST') {
    const { value } = req.body;
     if (!value) {
       return res.status(400).json({ message: 'Value is required to set the cookie' });
     }
    res.setHeader('Set-Cookie', `myCookie=${value}; Path=/; HttpOnly`); // Example setting a cookie
    res.status(200).json({ message: 'Cookie set successfully' });
  } else {
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

**Explanation:**

*   **Reading Cookies (GET):**  `req.cookies` is an object containing the cookies sent by the client.  We access the `myCookie` cookie.
*   **Setting Cookies (POST):**  `res.setHeader('Set-Cookie', ...)` sets a cookie.  The `Set-Cookie` header requires a specific format: `name=value; options`.
    *   `Path=/` specifies that the cookie is valid for all paths on the domain.
    *   `HttpOnly` makes the cookie inaccessible to client-side JavaScript, improving security (recommended).  Other security options include `Secure` (only send over HTTPS) and `SameSite` (controls cross-site request behavior).

**Important:** Remember to parse the request body to access the cookie value in a POST request (as shown in previous examples).  Also, client-side JavaScript libraries like `js-cookie` or similar can make managing cookies on the frontend easier.

## Connecting to Databases

API routes are excellent for interacting with databases. You can use any Node.js database driver to connect to your database.

Here's an example using `mongodb`:

```bash
npm install mongodb
```

```javascript
// pages/api/users.js
import { MongoClient } from 'mongodb';

const uri = process.env.MONGODB_URI; // Store your MongoDB connection string in an environment variable
const options = {
  useUnifiedTopology: true,
  useNewUrlParser: true,
};

let client;
let clientPromise;

if (!process.env.MONGODB_URI) {
  throw new Error('Please add your Mongo URI to .env.local');
}

if (process.env.NODE_ENV === 'development') {
  // In development mode, use a global variable so that the value
  // is preserved across module reloads caused by HMR (Hot Module Replacement).
  if (!global._mongoClientPromise) {
    client = new MongoClient(uri, options);
    global._mongoClientPromise = client.connect();
  }
  clientPromise = global._mongoClientPromise;
} else {
  // In production mode, it's best to not use a global variable.
  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

// Export a module-scoped MongoClient promise. By doing this in a
// separate module, the client can be shared across functions.
export default async function handler(req, res) {
  try {
    const client = await clientPromise;
    const db = client.db(process.env.MONGODB_DB); // Database name in environment variable
    const users = await db.collection('users').find({}).toArray();
    res.status(200).json(users);
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: 'Error connecting to database' });
  }
}
```

**Explanation:**

1.  **Install the MongoDB driver:** `npm install mongodb`
2.  **Import the MongoClient:** `import { MongoClient } from 'mongodb';`
3.  **Define the connection URI and options:**
    *   `MONGODB_URI`:  Store your MongoDB connection string (including username, password, and database name) in an environment variable for security. This prevents sensitive information from being exposed in your code.  Create a `.env.local` file in your project root and add:

        ```
        MONGODB_URI=mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<database>?retryWrites=true&w=majority
        MONGODB_DB=<your_database_name>
        ```

        Replace `<username>`, `<password>`, `<cluster>`, and `<database>` with your actual MongoDB credentials.
    *   `options`:  Optional configuration settings for the MongoDB connection. `useUnifiedTopology: true` and `useNewUrlParser: true` are recommended settings.
4.  **Manage the MongoClient instance:** The code carefully manages the `MongoClient` instance to avoid creating a new connection for every request, which can be inefficient. It uses a global variable in development mode and a separate connection in production mode.
5.  **Connect to the database:** `await clientPromise` establishes a connection to the MongoDB database.
6.  **Access the database and collection:** `client.db(process.env.MONGODB_DB)` gets a reference to your specified database (again, the database name is best stored in an environment variable).  `db.collection('users')` gets a reference to the "users" collection.
7.  **Query the database:** `db.collection('users').find({}).toArray()` retrieves all documents from the "users" collection and converts them to an array.
8.  **Send the response:** `res.status(200).json(users)` sends the array of users as a JSON response.
9.  **Error Handling:** The `try...catch` block handles potential errors during the database connection or query process, sending a 500 (Internal Server Error) response with an error message.

**Important Considerations for Database Connections:**

*   **Environment Variables:**  Always store your database connection string and other sensitive information in environment variables. This keeps your credentials secure and allows you to easily change them without modifying your code.
*   **Connection Pooling:**  Use connection pooling to reuse database connections and improve performance. The MongoDB driver typically handles connection pooling automatically.  The `MongoClient` instance should be reused across multiple API calls.
*   **Error Handling:**  Implement robust error handling to catch potential database connection or query errors.  Log errors for debugging.
*   **Data Validation:**  Validate user input before saving it to the database to prevent data corruption and security vulnerabilities.

##  CORS (Cross-Origin Resource Sharing)

By default, browsers prevent JavaScript code running on one origin (domain, protocol, and port) from making requests to a different origin. This is a security measure called the same-origin policy.  CORS is a mechanism that allows servers to explicitly permit cross-origin requests.

If you're making requests to your Next.js API routes from a different domain (e.g., from a frontend hosted on a different URL), you may need to configure CORS.

Here's how to enable CORS using the `cors` middleware (using `next-connect` for cleaner code):

```bash
npm install next-connect cors
```

```javascript
// pages/api/cors.js
import nextConnect from 'next-connect';
import cors from 'cors';

const handler = nextConnect();

handler.use(cors()); // Enable CORS for all origins

handler.get((req, res) => {
  res.status(200).json({ message: 'CORS enabled!' });
});

export default handler;
```

**Explanation:**

*   **Install the `cors` package:** `npm install cors`
*   **Import `cors`:** `import cors from 'cors';`
*   **Use the `cors()` middleware:**  `handler.use(cors());`  This will enable CORS for all origins.

**Customizing CORS:**

You can customize the CORS behavior by passing options to the `cors()` middleware:

```javascript
// pages/api/cors.js
import nextConnect from 'next-connect';
import cors from 'cors';

const handler = nextConnect();

const corsOptions = {
  origin: 'https://your-frontend-domain.com', // Allow requests only from this origin
  methods: ['GET', 'POST', 'PUT', 'DELETE'], // Allow these methods
  allowedHeaders: ['Content-Type', 'Authorization'], // Allow these headers
  credentials: true, // Allow cookies to be sent
};

handler.use(cors(corsOptions));

handler.get((req, res) => {
  res.status(200).json({ message: 'CORS enabled with custom options!' });
});

export default handler;
```

**Explanation:**

*   `origin`: Specifies the allowed origin(s). You can use a string for a single origin or an array of strings for multiple origins. You can also use `*` to allow all origins (not recommended for production).
*   `methods`: Specifies the allowed HTTP methods.
*   `allowedHeaders`: Specifies the allowed request headers.
*   `credentials`:  If set to `true`, allows cookies to be sent in cross-origin requests.

**Important:**  Be cautious when using `origin: '*'`, as it can expose your API to potential security vulnerabilities.  Only allow specific origins that you trust.

##  Error Handling

Robust error handling is crucial for production applications. Use `try...catch` blocks to catch potential errors and send appropriate error responses to the client.

```javascript
// pages/api/error.js
export default function handler(req, res) {
  try {
    // Simulate an error
    throw new Error('Something went wrong!');
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error', error: error.message }); // Send a 500 error
  }
}
```

**Explanation:**

*   We use a `try...catch` block to handle potential errors.
*   If an error occurs, we log it to the console using `console.error(error)`.
*   We send a 500 (Internal Server Error) response with a JSON object containing an error message and the error details.  Never expose potentially sensitive information directly to the client (e.g. stack traces), but log the error details to your server for debugging.

**Best Practices for Error Handling:**

*   **Log Errors:** Log errors to a centralized logging system for debugging and monitoring.
*   **Send Meaningful Error Messages:** Provide helpful error messages to the client, but avoid exposing sensitive information.
*   **Use Appropriate Status Codes:** Use appropriate HTTP status codes to indicate the type of error (e.g., 400 for bad request, 404 for not found, 500 for internal server error).

##  Middleware

Middleware functions are functions that have access to the request object (`req`), the response object (`res`), and the `next()` middleware function in the application's request-response cycle. They can modify the request and response objects, end the request-response cycle, or call the next middleware function in the stack.

We've already seen middleware with the `next-connect` and `cors` examples. Middleware is generally used for:

*   Authentication
*   Authorization
*   Logging
*   Body Parsing
*   CORS

`next-connect` simplifies using middleware in Next.js API routes.

##  Deployment

Next.js API routes are deployed as serverless functions. Vercel is the recommended platform for deploying Next.js applications, including API routes. When you deploy your Next.js application to Vercel, Vercel automatically detects your API routes in the `pages/api` directory and deploys them as serverless functions.

Other platforms like Netlify and AWS Lambda also support deploying Next.js API routes as serverless functions.

##  Advanced Techniques

*   **Authentication and Authorization:**  Implement authentication and authorization to protect your API routes.  Common methods include:
    *   JSON Web Tokens (JWT):  Use JWTs to authenticate users and authorize access to resources.
    *   API Keys:  Generate API keys for applications to access your API routes.
    *   OAuth:  Use OAuth to allow users to authenticate with third-party providers (e.g., Google, Facebook).

*   **Rate Limiting:**  Implement rate limiting to prevent abuse and protect your API routes from being overwhelmed by excessive requests.

*   **Caching:**  Use caching to improve performance by storing frequently accessed data in a cache.

*   **Background Jobs:**  Use background jobs to perform long-running tasks without blocking the main request-response cycle.  This is particularly useful for tasks like sending emails, processing images, or running complex calculations.  Consider using a queue system like Redis or RabbitMQ for managing background jobs.

##  Conclusion

Next.js API routes provide a powerful and convenient way to build backend functionality directly within your Next.js application.  They offer a serverless architecture, simplified development, and automatic scalability. By understanding the concepts and techniques covered in this guide, you can leverage API routes to create robust and scalable full-stack applications with Next.js. Remember to prioritize security, error handling, and performance optimization as you build your API routes.