---
title: 'HTML DOM NodeList entries(): Iterate with Key-Value Pairs for Efficient DOM Manipulation'
date: '2024-10-26'
lastmod: '2024-10-26'
tags: ['html', 'dom', 'javascript', 'nodelist', 'entries', 'iteration', 'dom-manipulation', 'web-development']
draft: false
summary: 'Learn how to use the `entries()` method on an HTML DOM NodeList to iterate through its nodes with key-value pairs, enabling more efficient and readable DOM manipulation in JavaScript.'
authors: ['default']
---

# HTML DOM NodeList entries(): Iterate with Key-Value Pairs for Efficient DOM Manipulation

The HTML DOM (Document Object Model) provides a powerful interface for interacting with web pages.  When working with collections of elements, the `NodeList` object is frequently encountered.  While `NodeList` is array-like, it doesn't offer all the same methods as a standard JavaScript array.  One useful method that *is* available is `entries()`, which allows you to iterate through the `NodeList` with key-value pairs, providing both the index and the node itself. This can lead to cleaner and more understandable code, especially when dealing with complex DOM manipulations.

## What is a NodeList?

Before diving into `entries()`, let's briefly review what a `NodeList` is. A `NodeList` is an ordered collection of nodes extracted from a document.  Common ways to obtain a `NodeList` include:

*   `document.querySelectorAll()`: Returns a `NodeList` of elements matching a CSS selector.
*   `element.childNodes`: Returns a `NodeList` of the element's child nodes.
*   `document.getElementsByClassName()`: Returns a live `HTMLCollection` (which is also array-like but with slightly different behavior, especially regarding live updates.  For most practical purposes, it behaves similarly to a `NodeList` in simple iteration scenarios).
*   `document.getElementsByTagName()`: Returns a live `HTMLCollection` (similar to `getElementsByClassName()`).

It's crucial to understand that a `NodeList` is *not* an array.  It's an *array-like* object.  This means you can access elements by index (e.g., `nodeList[0]`), and it has a `length` property, but it lacks many of the array methods like `map`, `filter`, and `reduce` directly.  That's where methods like `entries()` come in handy to bridge this gap.

## Understanding the `entries()` Method

The `entries()` method returns a new *iterator* object that contains key-value pairs for each index in the `NodeList`. The key is the index (starting from 0), and the value is the corresponding node in the `NodeList`.  This iterator can then be used in `for...of` loops or spread syntax.

### Syntax

```javascript
nodeList.entries()
```

### Return Value

An `iterator` object that yields arrays of `[index, node]` for each item in the `NodeList`.

## Using `entries()` for Iteration

Let's explore how to use `entries()` with practical examples.

### Example 1: Basic Iteration with `for...of`

This example selects all `<li>` elements within a `<ul>` and iterates through them, logging their index and text content.

```html
<ul id="myList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

<script>
  const listItems = document.querySelectorAll('#myList li');

  for (const [index, item] of listItems.entries()) {
    console.log(`Item at index ${index}: ${item.textContent}`);
  }
</script>
```

**Output in the console:**

```
Item at index 0: Item 1
Item at index 1: Item 2
Item at index 2: Item 3
```

**Explanation:**

1.  `document.querySelectorAll('#myList li')` selects all `<li>` elements within the `<ul>` with the ID `myList` and stores them in the `listItems` `NodeList`.
2.  `listItems.entries()` creates an iterator object.
3.  The `for...of` loop iterates through each key-value pair provided by the iterator.
4.  `[index, item]` destructures each pair into the `index` and `item` variables. `item` now holds the actual DOM node.
5.  `console.log()` outputs the index and the text content of each list item.

### Example 2: Modifying Node Attributes with `entries()`

This example iterates through a `NodeList` of images and adds an `alt` attribute to any images that don't already have one.

```html
<img src="image1.jpg" alt="Image 1">
<img src="image2.jpg">
<img src="image3.jpg" alt="Image 3">

<script>
  const images = document.querySelectorAll('img');

  for (const [index, image] of images.entries()) {
    if (!image.alt) {
      image.alt = `Image ${index + 1}`; // Provide a default alt text
    }
  }

  // Verify the changes (optional)
  images.forEach(img => console.log(img.alt));
</script>
```

**Explanation:**

1.  `document.querySelectorAll('img')` selects all `<img>` elements on the page.
2.  The `for...of` loop iterates through the `NodeList` using `entries()`.
3.  `if (!image.alt)` checks if the current image node has an `alt` attribute.
4.  If the `alt` attribute is missing, it's added with a default value based on the image's index.
5.  The optional `forEach` loop at the end verifies that the `alt` attributes have been correctly added.

### Example 3: Converting `NodeList` to Array with `entries()` and `Array.from()`

If you need to use array methods like `map`, `filter`, or `reduce`, you can easily convert a `NodeList` to an array using `Array.from()` in conjunction with `entries()` or spread syntax.  While `Array.from(NodeList)` directly converts a NodeList to an array, using `entries()` allows you to more effectively transform the *content* of the NodeList during the conversion process.

```html
<div class="item">Item A</div>
<div class="item">Item B</div>
<div class="item">Item C</div>

<script>
  const items = document.querySelectorAll('.item');

  // Create an array of the text content of each item
  const itemTexts = Array.from(items.entries(), ([index, item]) => `${index}: ${item.textContent}`);

  console.log(itemTexts); // Output: ["0: Item A", "1: Item B", "2: Item C"]
</script>
```

**Explanation:**

1.  `document.querySelectorAll('.item')` selects all elements with the class `item`.
2.  `Array.from(items.entries(), ([index, item]) => ...)` converts the `NodeList` to an array and transforms each element using a mapping function.
3.  `([index, item]) => `${index}: ${item.textContent}`` is the mapping function that creates a string with the index and text content of each item.

### Example 4: Using Spread Syntax with `entries()`

While using `Array.from()` is generally recommended for explicit conversion, spread syntax can provide a more concise way to work with the `entries()` iterator in some scenarios.

```html
<ul id="otherList">
  <li>List Item 1</li>
  <li>List Item 2</li>
  <li>List Item 3</li>
</ul>

<script>
  const otherListItems = document.querySelectorAll('#otherList li');
  const entriesArray = [...otherListItems.entries()]; // Convert to an array of [index, node] pairs

  console.log(entriesArray);
</script>
```

**Output (in console):**

```
[[0, <li>List Item 1</li>], [1, <li>List Item 2</li>], [2, <li>List Item 3</li>]]
```

This creates a standard JavaScript array where each element is an array containing the index and the corresponding DOM node.  You can then further process `entriesArray` using array methods.  Note that using spread syntax *without further mapping* simply provides an array of `[index, node]` arrays, rather than directly accessing the node properties as in the `Array.from()` example.

## Benefits of Using `entries()`

*   **Readability:**  `entries()` makes your code more readable by explicitly providing both the index and the node, making the iteration logic clearer.
*   **Efficiency:**  In many cases, knowing the index is necessary for DOM manipulation (e.g., modifying attributes based on position).  `entries()` avoids the need to manually track the index within the loop.
*   **Compatibility:**  `entries()` is widely supported in modern browsers.
*   **Clear Intent:**  Using `entries()` clearly signals your intent to iterate with access to both index and value, improving code maintainability.

## Considerations

*   **Live vs. Static NodeLists:**  Be mindful of whether your `NodeList` is "live" or "static."  Live `NodeLists` (e.g., from `element.childNodes`) update automatically as the DOM changes. Static `NodeLists` (e.g., from `document.querySelectorAll()`) are a snapshot of the DOM at the time they were created.  Modifying the DOM while iterating through a live `NodeList` can lead to unexpected behavior.  It's often best to convert a live `NodeList` to a static array (using `Array.from()`) before iterating if you plan to modify the DOM.
*   **Performance:**  For very large `NodeList` objects, converting to an array *before* iteration might offer a performance benefit, especially if you're performing complex DOM manipulations within the loop. However, for most common use cases, the performance difference will be negligible. Profile your code if performance is critical.
*   **Alternative: `forEach` with Index:** You *can* iterate over a `NodeList` using its `forEach` method and gain access to the index. However, the `for...of` loop with `entries()` often leads to cleaner and more readable code, particularly when destructuring the `[index, node]` pair directly in the loop definition.

## Conclusion

The `entries()` method provides a convenient and efficient way to iterate through HTML DOM `NodeList` objects with access to both the index and the node.  By understanding how to use `entries()`, you can write cleaner, more readable, and more maintainable code for manipulating the DOM in your web applications. Remember to consider the "live" or "static" nature of your `NodeList` and choose the most appropriate iteration method based on your specific needs.