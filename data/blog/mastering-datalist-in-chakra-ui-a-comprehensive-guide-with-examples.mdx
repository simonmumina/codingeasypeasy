---
title: 'Mastering DataList in Chakra UI: A Comprehensive Guide with Examples'
date: '2024-10-27'
lastmod: '2024-10-27'
tags: ['chakra-ui', 'data-list', 'react', 'ui-components', 'accessibility', 'performance']
draft: false
summary: 'Learn how to effectively use the DataList component in Chakra UI to display and manage large datasets with ease. This comprehensive guide covers everything from basic implementation to advanced customization and accessibility considerations, complete with code examples.'
authors: ['default']
---

# Mastering DataList in Chakra UI: A Comprehensive Guide with Examples

Chakra UI is a popular React component library that provides a set of accessible and reusable UI primitives to rapidly build modern web applications. Among its many useful components, the `DataList` component (often constructed from other Chakra UI components like `Box`, `Flex`, `Table`, etc.) provides a powerful way to display and manage data in a tabular format. While Chakra UI doesn't have a dedicated single component named `DataList`, its composable architecture allows for the creation of robust data lists.

This comprehensive guide will walk you through the process of building an effective DataList using Chakra UI, covering everything from basic implementation to advanced customization, accessibility considerations, and performance optimization.

## What is a DataList and Why Use Chakra UI?

A DataList (or data table) is a visual representation of data arranged in rows and columns. It's commonly used to display large datasets, allowing users to easily scan, sort, and filter information.

Using Chakra UI to build your DataList offers several advantages:

- **Accessibility:** Chakra UI components are designed with accessibility in mind, ensuring your DataList is usable by everyone, including users with disabilities.
- **Composability:** Chakra UI's composable architecture allows you to build complex UIs by combining simple components.
- **Theming:** Chakra UI provides a flexible theming system, allowing you to customize the appearance of your DataList to match your application's design.
- **Responsiveness:** Chakra UI components are responsive by default, ensuring your DataList looks great on all devices.
- **Performance:** Built with performance in mind, Chakra UI's components provide a smooth user experience.

## Building a Basic DataList with Chakra UI

Let's start by creating a simple DataList using Chakra UI components. We'll use `Box`, `Flex`, `Heading`, and other basic components to structure our data. This example will showcase dummy data.

```plaintext
import { Box, Flex, Heading, Text, Stack, useColorModeValue } from '@chakra-ui/react';

const data = [
  { id: 1, name: 'Alice', email: 'alice@example.com', age: 30 },
  { id: 2, name: 'Bob', email: 'bob@example.com', age: 25 },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', age: 35 },
  { id: 4, name: 'David', email: 'david@example.com', age: 28 },
];

const DataList = () => {
  const bg = useColorModeValue('gray.50', 'gray.700');
  const textColor = useColorModeValue('gray.700', 'gray.300');
  return (
    <Box borderWidth="1px" borderRadius="md" overflow="hidden" bg={bg} color={textColor}>
      <Flex
        as="thead"
        bg={useColorModeValue('gray.100', 'gray.800')}
        color={useColorModeValue('gray.700', 'gray.300')}
      >
        <Flex flex="1" padding="4" fontWeight="semibold" fontSize="sm" textTransform="uppercase">
          ID
        </Flex>
        <Flex flex="2" padding="4" fontWeight="semibold" fontSize="sm" textTransform="uppercase">
          Name
        </Flex>
        <Flex flex="2" padding="4" fontWeight="semibold" fontSize="sm" textTransform="uppercase">
          Email
        </Flex>
        <Flex flex="1" padding="4" fontWeight="semibold" fontSize="sm" textTransform="uppercase">
          Age
        </Flex>
      </Flex>

      <Box as="tbody">
        {data.map((item) => (
          <Flex key={item.id} padding="4" borderBottom="1px solid" borderColor={useColorModeValue('gray.200', 'gray.600')}>
            <Flex flex="1">{item.id}</Flex>
            <Flex flex="2">{item.name}</Flex>
            <Flex flex="2">{item.email}</Flex>
            <Flex flex="1">{item.age}</Flex>
          </Flex>
        ))}
      </Box>
    </Box>
  );
};

export default DataList;

```

**Explanation:**

- We import necessary Chakra UI components like `Box`, `Flex`, `Heading`, and `Text`.
- We define a `data` array representing our data source.
- We use `Box` to create a container for the DataList with a border and rounded corners.
- We use `Flex` to simulate `thead` and `tbody` elements for structure.
- We use `Flex` again to create individual rows and cells within the DataList.
- `useColorModeValue` dynamically changes the background and text colors based on the current theme (light or dark).

## Enhancing the DataList with Table Components

While the previous example used `Box` and `Flex` for layout, Chakra UI also offers components tailored for building tables which provides more semantic markup. Here's how you can use `Table`, `Thead`, `Tbody`, `Tr`, `Th`, and `Td` components to create a more structured DataList:

```plaintext
import {
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableCaption,
  TableContainer,
  useColorModeValue
} from '@chakra-ui/react';

const data = [
  { id: 1, name: 'Alice', email: 'alice@example.com', age: 30 },
  { id: 2, name: 'Bob', email: 'bob@example.com', age: 25 },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', age: 35 },
  { id: 4, name: 'David', email: 'david@example.com', age: 28 },
];

const DataListTable = () => {
  const bg = useColorModeValue('gray.50', 'gray.700');
  const textColor = useColorModeValue('gray.700', 'gray.300');

  return (
    <TableContainer borderWidth="1px" borderRadius="md" overflowX="auto" bg={bg} color={textColor}>
      <Table variant="simple">
        <TableCaption>User Data</TableCaption>
        <Thead bg={useColorModeValue('gray.100', 'gray.800')} color={useColorModeValue('gray.700', 'gray.300')}>
          <Tr>
            <Th>ID</Th>
            <Th>Name</Th>
            <Th>Email</Th>
            <Th>Age</Th>
          </Tr>
        </Thead>
        <Tbody>
          {data.map((item) => (
            <Tr key={item.id}>
              <Td>{item.id}</Td>
              <Td>{item.name}</Td>
              <Td>{item.email}</Td>
              <Td>{item.age}</Td>
            </Tr>
          ))}
        </Tbody>
      </Table>
    </TableContainer>
  );
};

export default DataListTable;
```

**Explanation:**

- We import the table-specific components: `Table`, `Thead`, `Tbody`, `Tr`, `Th`, and `Td`.
- `TableContainer` provides a container for the table, enabling horizontal scrolling if needed (`overflowX="auto"`).
- `Table` component acts as the main wrapper
- `Thead` and `Tbody` provide semantic structure for the header and body of the table.
- `Tr` represents a table row.
- `Th` represents a table header cell.
- `Td` represents a table data cell.
- A `TableCaption` is also added for accessibility.

## Adding Sorting Functionality

DataLists are often more useful when users can sort the data. Let's add sorting functionality to our DataList.

```plaintext
import {
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableContainer,
  IconButton,
  useColorModeValue
} from '@chakra-ui/react';
import { TriangleDownIcon, TriangleUpIcon } from '@chakra-ui/icons';
import { useState } from 'react';

const data = [
  { id: 1, name: 'Alice', email: 'alice@example.com', age: 30 },
  { id: 2, name: 'Bob', email: 'bob@example.com', age: 25 },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', age: 35 },
  { id: 4, name: 'David', email: 'david@example.com', age: 28 },
];

const DataListSortable = () => {
  const [sortColumn, setSortColumn] = useState(null);
  const [sortDirection, setSortDirection] = useState('asc');
  const bg = useColorModeValue('gray.50', 'gray.700');
  const textColor = useColorModeValue('gray.700', 'gray.300');

  const handleSort = (column) => {
    if (column === sortColumn) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(column);
      setSortDirection('asc');
    }
  };

  const sortedData = [...data].sort((a, b) => {
    if (sortColumn) {
      const aValue = a[sortColumn];
      const bValue = b[sortColumn];

      if (aValue < bValue) {
        return sortDirection === 'asc' ? -1 : 1;
      }
      if (aValue > bValue) {
        return sortDirection === 'asc' ? 1 : -1;
      }
    }
    return 0;
  });


  return (
    <TableContainer borderWidth="1px" borderRadius="md" overflowX="auto" bg={bg} color={textColor}>
      <Table variant="simple">
        <Thead bg={useColorModeValue('gray.100', 'gray.800')} color={useColorModeValue('gray.700', 'gray.300')}>
          <Tr>
            <Th>
              ID
              <IconButton
                aria-label="Sort by ID"
                icon={sortColumn === 'id' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                onClick={() => handleSort('id')}
                size="sm"
                variant="ghost"
              />
            </Th>
            <Th>
              Name
              <IconButton
                aria-label="Sort by Name"
                icon={sortColumn === 'name' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                onClick={() => handleSort('name')}
                size="sm"
                variant="ghost"
              />
            </Th>
            <Th>
              Email
              <IconButton
                aria-label="Sort by Email"
                icon={sortColumn === 'email' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                onClick={() => handleSort('email')}
                size="sm"
                variant="ghost"
              />
            </Th>
            <Th>
              Age
              <IconButton
                aria-label="Sort by Age"
                icon={sortColumn === 'age' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                onClick={() => handleSort('age')}
                size="sm"
                variant="ghost"
              />
            </Th>
          </Tr>
        </Thead>
        <Tbody>
          {sortedData.map((item) => (
            <Tr key={item.id}>
              <Td>{item.id}</Td>
              <Td>{item.name}</Td>
              <Td>{item.email}</Td>
              <Td>{item.age}</Td>
            </Tr>
          ))}
        </Tbody>
      </Table>
    </TableContainer>
  );
};

export default DataListSortable;
```

**Explanation:**

- We introduce `useState` hooks to manage the `sortColumn` and `sortDirection`.
- The `handleSort` function updates the `sortColumn` and `sortDirection` when a header is clicked.
- The `sortedData` array is created using the `sort` method, applying the sorting logic based on the `sortColumn` and `sortDirection`.
- We use `IconButton` with `TriangleUpIcon` and `TriangleDownIcon` from Chakra UI Icons to visually indicate the sorting direction. The icon changes based on the current sort state.

## Adding Pagination

For large datasets, pagination is crucial for performance and usability. Here's how to implement pagination:

```plaintext
import {
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableContainer,
  IconButton,
  Flex,
  Text,
  Select,
  useColorModeValue
} from '@chakra-ui/react';
import { TriangleDownIcon, TriangleUpIcon, ChevronLeftIcon, ChevronRightIcon } from '@chakra-ui/icons';
import { useState, useMemo } from 'react';

const data = [
  // ... (Same data as before, but expanded to a larger array)
  { id: 1, name: 'Alice', email: 'alice@example.com', age: 30 },
  { id: 2, name: 'Bob', email: 'bob@example.com', age: 25 },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', age: 35 },
  { id: 4, name: 'David', email: 'david@example.com', age: 28 },
  { id: 5, name: 'Eve', email: 'eve@example.com', age: 22 },
  { id: 6, name: 'Fiona', email: 'fiona@example.com', age: 40 },
  { id: 7, name: 'George', email: 'george@example.com', age: 32 },
  { id: 8, name: 'Hannah', email: 'hannah@example.com', age: 27 },
  { id: 9, name: 'Isaac', email: 'isaac@example.com', age: 33 },
  { id: 10, name: 'Julia', email: 'julia@example.com', age: 29 },
  { id: 11, name: 'Kevin', email: 'kevin@example.com', age: 31 },
  { id: 12, name: 'Laura', email: 'laura@example.com', age: 26 },
  { id: 13, name: 'Michael', email: 'michael@example.com', age: 38 },
  { id: 14, name: 'Natalie', email: 'natalie@example.com', age: 24 },
  { id: 15, name: 'Oliver', email: 'oliver@example.com', age: 36 },
  { id: 16, name: 'Penelope', email: 'penelope@example.com', age: 23 },
  { id: 17, name: 'Quentin', email: 'quentin@example.com', age: 39 },
  { id: 18, name: 'Rachel', email: 'rachel@example.com', age: 21 },
  { id: 19, name: 'Samuel', email: 'samuel@example.com', age: 34 },
  { id: 20, name: 'Tina', email: 'tina@example.com', age: 37 },
];


const DataListPaginated = () => {
  const [sortColumn, setSortColumn] = useState(null);
  const [sortDirection, setSortDirection] = useState('asc');
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(5);
  const bg = useColorModeValue('gray.50', 'gray.700');
  const textColor = useColorModeValue('gray.700', 'gray.300');

  const handleSort = (column) => {
    if (column === sortColumn) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(column);
      setSortDirection('asc');
    }
  };

  const sortedData = useMemo(() => {
        const sorted = [...data].sort((a, b) => {
            if (sortColumn) {
                const aValue = a[sortColumn];
                const bValue = b[sortColumn];

                if (aValue < bValue) {
                    return sortDirection === 'asc' ? -1 : 1;
                }
                if (aValue > bValue) {
                    return sortDirection === 'asc' ? 1 : -1;
                }
            }
            return 0;
        });
        return sorted;
    }, [data, sortColumn, sortDirection]);

    const pageCount = Math.ceil(data.length / pageSize);
    const paginatedData = useMemo(() => {
        const startIndex = (page - 1) * pageSize;
        return sortedData.slice(startIndex, startIndex + pageSize);
    }, [sortedData, page, pageSize]);


  return (
    <Flex direction="column">
      <TableContainer borderWidth="1px" borderRadius="md" overflowX="auto" bg={bg} color={textColor}>
        <Table variant="simple">
          <Thead bg={useColorModeValue('gray.100', 'gray.800')} color={useColorModeValue('gray.700', 'gray.300')}>
            <Tr>
              <Th>
                ID
                <IconButton
                  aria-label="Sort by ID"
                  icon={sortColumn === 'id' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                  onClick={() => handleSort('id')}
                  size="sm"
                  variant="ghost"
                />
              </Th>
              <Th>
                Name
                <IconButton
                  aria-label="Sort by Name"
                  icon={sortColumn === 'name' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                  onClick={() => handleSort('name')}
                  size="sm"
                  variant="ghost"
                />
              </Th>
              <Th>
                Email
                <IconButton
                  aria-label="Sort by Email"
                  icon={sortColumn === 'email' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                  onClick={() => handleSort('email')}
                  size="sm"
                  variant="ghost"
                />
              </Th>
              <Th>
                Age
                <IconButton
                  aria-label="Sort by Age"
                  icon={sortColumn === 'age' && sortDirection === 'asc' ? <TriangleUpIcon /> : <TriangleDownIcon />}
                  onClick={() => handleSort('age')}
                  size="sm"
                  variant="ghost"
                />
              </Th>
            </Tr>
          </Thead>
          <Tbody>
            {paginatedData.map((item) => (
              <Tr key={item.id}>
                <Td>{item.id}</Td>
                <Td>{item.name}</Td>
                <Td>{item.email}</Td>
                <Td>{item.age}</Td>
              </Tr>
            ))}
          </Tbody>
        </Table>
      </TableContainer>

      <Flex justify="space-between" align="center" mt={4}>
        <Flex align="center">
          <Text mr={2}>Items per page:</Text>
          <Select
            value={pageSize}
            onChange={(e) => {
              setPageSize(Number(e.target.value));
              setPage(1); // Reset to first page when page size changes
            }}
            size="sm"
            width="auto"
          >
            <option value={5}>5</option>
            <option value={10}>10</option>
            <option value={20}>20</option>
          </Select>
        </Flex>

        <Flex align="center">
          <IconButton
            aria-label="Previous Page"
            icon={<ChevronLeftIcon />}
            onClick={() => setPage(Math.max(1, page - 1))}
            isDisabled={page === 1}
            size="sm"
            mr={2}
            variant="ghost"
          />
          <Text>
            Page {page} of {pageCount}
          </Text>
          <IconButton
            aria-label="Next Page"
            icon={<ChevronRightIcon />}
            onClick={() => setPage(Math.min(pageCount, page + 1))}
            isDisabled={page === pageCount}
            size="sm"
            ml={2}
            variant="ghost"
          />
        </Flex>
      </Flex>
    </Flex>
  );
};

export default DataListPaginated;
```

**Explanation:**

- We introduce `useState` hooks for `page` and `pageSize`.
- We calculate the `pageCount` based on the `data.length` and `pageSize`.
- The `paginatedData` array is created using the `slice` method, extracting the data for the current page.
- We use `IconButton` with `ChevronLeftIcon` and `ChevronRightIcon` for navigation.
- A `Select` component allows users to choose the `pageSize`.
- `useMemo` is used to memoize `sortedData` and `paginatedData` to prevent unnecessary re-renders.

## Accessibility Considerations

Accessibility is paramount when building web applications. Here are some key accessibility considerations for DataLists:

- **Semantic HTML:** Use semantic HTML elements like `<Table>`, `<Thead>`, `<Tbody>`, `<Tr>`, `<Th>`, and `<Td>` to provide structure and meaning to your DataList. This allows screen readers to properly interpret the table structure.
- **ARIA Attributes:** Use ARIA attributes to provide additional information about the DataList to assistive technologies. For example, use `aria-label` on sortable columns or navigation buttons.
- **Keyboard Navigation:** Ensure users can navigate the DataList using the keyboard. Use proper focus management and ensure all interactive elements are focusable.
- **Color Contrast:** Ensure sufficient color contrast between text and background colors to meet WCAG guidelines. Chakra UI's theming system can help with this.
- **Screen Reader Testing:** Thoroughly test your DataList with a screen reader to identify and address any accessibility issues.
- **Table Caption:** Use `TableCaption` component to provide a title or description of your table.

## Performance Optimization

When dealing with large datasets, performance is a critical concern. Here are some techniques to optimize the performance of your DataList:

- **Virtualization:** Virtualization (or windowing) renders only the visible rows of the DataList, improving performance significantly for large datasets. Libraries like `react-virtualized` can be used for this purpose. However, these libraries are often incompatible with Chakra UI styling, and require significant customization to integrate.
- **Memoization:** Use `React.memo` or `useMemo` to memoize components and calculations that don't need to be re-rendered frequently. This prevents unnecessary re-renders and improves performance. In the examples above, `useMemo` is used for sorting and pagination.
- **Pagination:** Implement pagination to divide the data into smaller chunks, reducing the amount of data that needs to be rendered at once.
- **Lazy Loading:** If you're loading data from an external source, use lazy loading to load data only when it's needed.
- **Code Splitting:** Use code splitting to break your application into smaller bundles, improving initial load time.

## Advanced Customization

Chakra UI offers a high degree of customization. Here are some ways to customize your DataList:

- **Theming:** Use Chakra UI's theming system to customize the colors, fonts, and other styles of your DataList.
- **Custom Components:** Create custom components for rendering cells or rows in your DataList. This allows you to display complex data or add custom interactions.
- **Conditional Rendering:** Use conditional rendering to display different content based on the data or user interaction.
- **Event Handling:** Add event handlers to cells or rows to respond to user actions like clicks or hovers.

## Conclusion

This comprehensive guide has provided you with a solid foundation for building effective DataLists using Chakra UI. By understanding the core concepts, implementing essential features like sorting and pagination, and considering accessibility and performance, you can create DataLists that are both functional and user-friendly. Experiment with different components, customization options, and optimization techniques to tailor your DataLists to your specific needs. Remember to prioritize accessibility and performance to ensure a positive user experience for everyone.
