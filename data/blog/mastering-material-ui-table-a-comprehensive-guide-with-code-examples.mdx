---
title: 'Mastering Material UI Table: A Comprehensive Guide with Code Examples'
date: '2024-01-26'
lastmod: '2024-01-26'
tags: ['material-ui', 'mui', 'react', 'table', 'data-grid', 'frontend development', 'component library', 'javascript']
draft: false
summary: 'A deep dive into Material UI Table (MUI Table), exploring its components, customization options, and best practices with detailed code examples. Learn how to create responsive, interactive, and visually appealing tables in your React applications.'
authors: ['AI Assistant']
---

# Mastering Material UI Table: A Comprehensive Guide with Code Examples

Material UI (MUI) provides a powerful and versatile set of components for building user interfaces in React.  Among these, the `Table` component stands out as an essential tool for displaying tabular data in a clear and organized manner. This guide will walk you through everything you need to know to effectively use and customize the Material UI Table component, from basic setup to advanced features.

## Why Choose Material UI Table?

Material UI Table offers several advantages:

*   **Pre-built Components:** Provides readily available components for creating tables with minimal code.
*   **Customization:** Highly customizable to match your application's design and functionality.
*   **Accessibility:** Adheres to accessibility best practices, ensuring your tables are usable by everyone.
*   **Responsiveness:**  Easily create responsive tables that adapt to different screen sizes.
*   **Integration:** Seamlessly integrates with other Material UI components and React ecosystem.

## Getting Started: Installation

Before diving into the code, make sure you have Material UI installed in your project.  If not, you can install it using npm or yarn:

```bash
npm install @mui/material @emotion/react @emotion/styled
# or
yarn add @mui/material @emotion/react @emotion/styled
```

## Basic Table Structure

The core components for building a Material UI Table are:

*   `Table`: The root component, acting as the container.
*   `TableHead`:  Contains the table header row(s).
*   `TableBody`: Contains the table data rows.
*   `TableRow`: Represents a single row in the table.
*   `TableCell`: Represents a single cell in a row.
*   `TableContainer`: Provides scrolling and other container-related functionalities.
*   `TableFooter`: Contains footer content like pagination.
*   `TablePagination`: Component for handling table pagination.

Here's a basic example:

```jsx
import React from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
];

function BasicTable() {
  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 650 }} aria-label="simple table">
        <TableHead>
          <TableRow>
            <TableCell>Dessert (100g serving)</TableCell>
            <TableCell align="right">Calories</TableCell>
            <TableCell align="right">Fat&nbsp;(g)</TableCell>
            <TableCell align="right">Carbs&nbsp;(g)</TableCell>
            <TableCell align="right">Protein&nbsp;(g)</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row) => (
            <TableRow
              key={row.name}
              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
            >
              <TableCell component="th" scope="row">
                {row.name}
              </TableCell>
              <TableCell align="right">{row.calories}</TableCell>
              <TableCell align="right">{row.fat}</TableCell>
              <TableCell align="right">{row.carbs}</TableCell>
              <TableCell align="right">{row.protein}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

export default BasicTable;
```

**Explanation:**

*   We import necessary components from `@mui/material`.
*   `createData` function helps to format our data into objects.
*   `rows` array contains sample data.
*   `TableContainer` wraps the `Table` component providing scrolling functionality (when needed).
*   `TableHead` renders the header row.  We use `TableCell` and `TableRow` to define the header.
*   `TableBody` renders the table content.  We map over the `rows` array to create a `TableRow` for each item.
*   `TableCell` renders each data cell within a row.  The `align="right"` property aligns the text to the right.  The `sx` prop allows you to apply custom styles using Material UI's styling system (styled-components or emotion).

## Customizing Table Appearance

Material UI offers various ways to customize the appearance of your tables:

*   **Styling with `sx` prop:**  The `sx` prop allows you to apply styles directly to components using CSS-in-JS.
*   **Theming:** Use Material UI's theming system to define a consistent look and feel across your application.
*   **Styled Components:** Utilize `styled` to create reusable, styled components for your table elements.

Here's an example using the `sx` prop to customize table cell colors:

```jsx
import React from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
];

function CustomStyledTable() {
  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 650 }} aria-label="custom styled table">
        <TableHead>
          <TableRow>
            <TableCell sx={{ fontWeight: 'bold', backgroundColor: '#f0f0f0' }}>
              Dessert (100g serving)
            </TableCell>
            <TableCell align="right" sx={{ fontWeight: 'bold', backgroundColor: '#f0f0f0' }}>
              Calories
            </TableCell>
            <TableCell align="right" sx={{ fontWeight: 'bold', backgroundColor: '#f0f0f0' }}>
              Fat&nbsp;(g)
            </TableCell>
            <TableCell align="right" sx={{ fontWeight: 'bold', backgroundColor: '#f0f0f0' }}>
              Carbs&nbsp;(g)
            </TableCell>
            <TableCell align="right" sx={{ fontWeight: 'bold', backgroundColor: '#f0f0f0' }}>
              Protein&nbsp;(g)
            </TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row) => (
            <TableRow
              key={row.name}
              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
            >
              <TableCell component="th" scope="row">
                {row.name}
              </TableCell>
              <TableCell align="right">{row.calories}</TableCell>
              <TableCell align="right">{row.fat}</TableCell>
              <TableCell align="right">{row.carbs}</TableCell>
              <TableCell align="right">{row.protein}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

export default CustomStyledTable;
```

## Adding Interactivity: Sorting and Selection

Material UI Tables can be made interactive by implementing sorting and selection features.

### Sorting

To implement sorting, you'll typically need to:

1.  Maintain a state variable to store the current sorting order (e.g., column to sort by and direction).
2.  Create a function to handle the sort action and update the state.
3.  Apply the sorting logic to your data array.
4.  Display sort indicators (e.g., arrows) in the table header.

Here's a basic example with sorting:

```jsx
import React, { useState } from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import TableSortLabel from '@mui/material/TableSortLabel';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
];

function descendingComparator(a, b, orderBy) {
  if (b[orderBy] < a[orderBy]) {
    return -1;
  }
  if (b[orderBy] > a[orderBy]) {
    return 1;
  }
  return 0;
}

function getComparator(order, orderBy) {
  return order === 'desc'
    ? (a, b) => descendingComparator(a, b, orderBy)
    : (a, b) => -descendingComparator(a, b, orderBy);
}

function stableSort(array, comparator) {
  const stabilizedThis = array.map((el, index) => [el, index]);
  stabilizedThis.sort((a, b) => {
    const order = comparator(a[0], b[0]);
    if (order !== 0) {
      return order;
    }
    return a[1] - b[1];
  });
  return stabilizedThis.map((el) => el[0]);
}

function EnhancedTableHead(props) {
  const { order, orderBy, onRequestSort } = props;
  const createSortHandler = (property) => (event) => {
    onRequestSort(event, property);
  };

  const headCells = [
    { id: 'name', numeric: false, disablePadding: false, label: 'Dessert (100g serving)' },
    { id: 'calories', numeric: true, disablePadding: false, label: 'Calories' },
    { id: 'fat', numeric: true, disablePadding: false, label: 'Fat\u00a0(g)' },
    { id: 'carbs', numeric: true, disablePadding: false, label: 'Carbs\u00a0(g)' },
    { id: 'protein', numeric: true, disablePadding: false, label: 'Protein\u00a0(g)' },
  ];

  return (
    <TableHead>
      <TableRow>
        {headCells.map((headCell) => (
          <TableCell
            key={headCell.id}
            align={headCell.numeric ? 'right' : 'left'}
            padding={headCell.disablePadding ? 'none' : 'normal'}
            sortDirection={orderBy === headCell.id ? order : false}
          >
            <TableSortLabel
              active={orderBy === headCell.id}
              direction={orderBy === headCell.id ? order : 'asc'}
              onClick={createSortHandler(headCell.id)}
            >
              {headCell.label}
            </TableSortLabel>
          </TableCell>
        ))}
      </TableRow>
    </TableHead>
  );
}


function SortableTable() {
  const [order, setOrder] = useState('asc');
  const [orderBy, setOrderBy] = useState('calories');  // Default sort column
  const [data, setData] = useState([...rows]);

  const handleRequestSort = (event, property) => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  const sortedData = stableSort(data, getComparator(order, orderBy));


  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 750 }} aria-labelledby="tableTitle">
        <EnhancedTableHead
            order={order}
            orderBy={orderBy}
            onRequestSort={handleRequestSort}
          />
        <TableBody>
          {sortedData.map((row) => (
            <TableRow
              key={row.name}
              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
            >
              <TableCell component="th" scope="row">
                {row.name}
              </TableCell>
              <TableCell align="right">{row.calories}</TableCell>
              <TableCell align="right">{row.fat}</TableCell>
              <TableCell align="right">{row.carbs}</TableCell>
              <TableCell align="right">{row.protein}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

export default SortableTable;
```

**Key improvements and explanation of the sorting example:**

*   **`stableSort` Function:**  Crucially important.  This function maintains the original order of elements when they have equal values in the sorted column.  This prevents the table from "shuffling" items that are identical in the currently sorted column.  It does this by attaching the original index of the array item to it during sorting, using this index for tie-breaking.
*   **`getComparator` and `descendingComparator`:** These functions define the comparison logic for sorting in ascending or descending order, respectively.  They are separated for clarity and reusability.
*   **`EnhancedTableHead` Component:** This is now a separate component responsible for rendering the table header with sortable labels.  This makes the main component cleaner and more focused on the data display.  It receives the `order`, `orderBy`, and `onRequestSort` props from the parent component, allowing it to trigger the sorting logic.  The `headCells` array defines the columns and their properties (id, label, numeric).  It uses `<TableSortLabel>` to display the sort indicator and handle click events.
*   **`handleRequestSort` Function:** This function is called when a header cell is clicked to trigger sorting. It updates the `order` and `orderBy` state variables, which then cause the table to re-render with the sorted data.
*   **`useState` Hook:** Used to manage the `order`, `orderBy`, and data (as data will be sorted) state.
*   **`TableSortLabel`:** The core of the sorting implementation.  This component handles the visual indicator (arrow) and the click event to initiate the sorting.
*   **Data State:** The `rows` data is now copied using the spread operator `[...rows]` and stored in the `data` state.  This is essential because `sort` in JavaScript modifies the array in place. We need to maintain the original data.  Also important is to update the state using `setData` with sorted data instead of sorting rows in place.

### Selection

To add row selection:

1.  Maintain an array to store the selected row IDs (or indices).
2.  Add a checkbox or radio button to each row.
3.  Update the selected row IDs array when the checkbox/radio button is toggled.
4.  Visually highlight the selected rows.

```jsx
import React, { useState } from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import Checkbox from '@mui/material/Checkbox';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
];

function SelectableTable() {
  const [selected, setSelected] = useState([]);

  const handleSelectAllClick = (event) => {
    if (event.target.checked) {
      const newSelecteds = rows.map((n) => n.name);
      setSelected(newSelecteds);
      return;
    }
    setSelected([]);
  };

  const handleClick = (event, name) => {
    const selectedIndex = selected.indexOf(name);
    let newSelected = [];

    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, name);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selected.slice(0, selectedIndex),
        selected.slice(selectedIndex + 1),
      );
    }

    setSelected(newSelected);
  };

  const isSelected = (name) => selected.indexOf(name) !== -1;

  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 650 }} aria-label="selectable table">
        <TableHead>
          <TableRow>
            <TableCell padding="checkbox">
              <Checkbox
                indeterminate={selected.length > 0 && selected.length < rows.length}
                checked={rows.length > 0 && selected.length === rows.length}
                onChange={handleSelectAllClick}
                inputProps={{ 'aria-label': 'select all desserts' }}
              />
            </TableCell>
            <TableCell>Dessert (100g serving)</TableCell>
            <TableCell align="right">Calories</TableCell>
            <TableCell align="right">Fat&nbsp;(g)</TableCell>
            <TableCell align="right">Carbs&nbsp;(g)</TableCell>
            <TableCell align="right">Protein&nbsp;(g)</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row, index) => {
            const isItemSelected = isSelected(row.name);
            const labelId = `enhanced-table-checkbox-${index}`;

            return (
              <TableRow
                hover
                onClick={(event) => handleClick(event, row.name)}
                role="checkbox"
                aria-checked={isItemSelected}
                tabIndex={-1}
                key={row.name}
                selected={isItemSelected}
                sx={{ cursor: 'pointer' }}
              >
                <TableCell padding="checkbox">
                  <Checkbox
                    checked={isItemSelected}
                    inputProps={{ 'aria-labelledby': labelId }}
                  />
                </TableCell>
                <TableCell component="th" id={labelId} scope="row" padding="normal">
                  {row.name}
                </TableCell>
                <TableCell align="right">{row.calories}</TableCell>
                <TableCell align="right">{row.fat}</TableCell>
                <TableCell align="right">{row.carbs}</TableCell>
                <TableCell align="right">{row.protein}</TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

export default SelectableTable;
```

**Explanation of selection example:**

*   **`selected` State:** An array to store the names of the selected rows.
*   **`handleSelectAllClick`:** Handles the "select all" checkbox.
*   **`handleClick`:** Handles individual row selection.  It toggles the row's selection state in the `selected` array using a robust method that handles adding and removing items correctly, avoiding mutation of state.
*   **`isSelected`:** A helper function to check if a row is selected.
*   **Checkbox Integration:** A checkbox is added to each row and the header to enable selection.  The `checked` prop is dynamically set based on the `isSelected` function.
*   **Row Highlighting:** The `selected` prop on the `TableRow` component visually highlights the selected rows.  Also, hover effect is added to the rows.
*   **Accessibility:** The `aria-labelledby` prop on the checkbox and the use of `aria-checked` and `role="checkbox"` enhance accessibility.

## Responsiveness

To make your tables responsive, consider these techniques:

*   **`TableContainer` with `overflowX="auto"`:** Provides horizontal scrolling on smaller screens.
*   **Conditional Rendering:** Hide or show columns based on screen size using media queries or responsive hooks.
*   **Data Grid:** If you need advanced features like virtualized rendering and column resizing, consider using the `DataGrid` component from `@mui/x-data-grid`. This component offers more built-in responsiveness features.

Here's an example of a responsive table using `TableContainer` with `overflowX="auto"`:

```jsx
import React from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
  createData('Cake', 356, 16.0, 49, 3.9),
  createData('Brownie', 356, 16.0, 49, 3.9),
];

function ResponsiveTable() {
  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 650 }} aria-label="responsive table">
        <TableHead>
          <TableRow>
            <TableCell>Dessert (100g serving)</TableCell>
            <TableCell align="right">Calories</TableCell>
            <TableCell align="right">Fat&nbsp;(g)</TableCell>
            <TableCell align="right">Carbs&nbsp;(g)</TableCell>
            <TableCell align="right">Protein&nbsp;(g)</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row) => (
            <TableRow
              key={row.name}
              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
            >
              <TableCell component="th" scope="row">
                {row.name}
              </TableCell>
              <TableCell align="right">{row.calories}</TableCell>
              <TableCell align="right">{row.fat}</TableCell>
              <TableCell align="right">{row.carbs}</TableCell>
              <TableCell align="right">{row.protein}</TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}

export default ResponsiveTable;
```

The key is the `TableContainer` component wrapping the `Table` and the implicit style `overflowX: auto`. This allows the table to scroll horizontally on smaller screens when the content overflows.

## Table Pagination

`TablePagination` helps to split the table into pages to improve readability.  Here is an example:

```jsx
import React, { useState } from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import TablePagination from '@mui/material/TablePagination';
import Paper from '@mui/material/Paper';

function createData(name, calories, fat, carbs, protein) {
  return { name, calories, fat, carbs, protein };
}

const rows = [
  createData('Frozen yoghurt', 159, 6.0, 24, 4.0),
  createData('Ice cream sandwich', 237, 9.0, 37, 4.3),
  createData('Eclair', 262, 16.0, 24, 6.0),
  createData('Cupcake', 305, 3.7, 67, 4.3),
  createData('Gingerbread', 356, 16.0, 49, 3.9),
  createData('Cake', 356, 16.0, 49, 3.9),
  createData('Brownie', 356, 16.0, 49, 3.9),
  createData('Donut', 452, 25.0, 51, 4.9),
  createData('Pie', 518, 26.0, 65, 7.0),
  createData('Waffle', 360, 16.0, 42, 3.5),
];

function PaginatedTable() {
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(5);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const emptyRows =
    page > 0 ? Math.max(0, (1 + page) * rowsPerPage - rows.length) : 0;

  return (
    <TableContainer component={Paper}>
      <Table sx={{ minWidth: 650 }} aria-label="paginated table">
        <TableHead>
          <TableRow>
            <TableCell>Dessert (100g serving)</TableCell>
            <TableCell align="right">Calories</TableCell>
            <TableCell align="right">Fat&nbsp;(g)</TableCell>
            <TableCell align="right">Carbs&nbsp;(g)</TableCell>
            <TableCell align="right">Protein&nbsp;(g)</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {(rowsPerPage > 0
            ? rows.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
            : rows
          ).map((row) => (
            <TableRow key={row.name}>
              <TableCell component="th" scope="row">
                {row.name}
              </TableCell>
              <TableCell align="right">{row.calories}</TableCell>
              <TableCell align="right">{row.fat}</TableCell>
              <TableCell align="right">{row.carbs}</TableCell>
              <TableCell align="right">{row.protein}</TableCell>
            </TableRow>
          ))}

          {emptyRows > 0 && (
            <TableRow style={{ height: 53 * emptyRows }}>
              <TableCell colSpan={6} />
            </TableRow>
          )}
        </TableBody>
      </Table>
      <TablePagination
        rowsPerPageOptions={[5, 10, 25, { label: 'All', value: -1 }]}
        component="div"
        count={rows.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onPageChange={handleChangePage}
        onRowsPerPageChange={handleChangeRowsPerPage}
      />
    </TableContainer>
  );
}

export default PaginatedTable;
```

**Explanation:**

*   **State Variables:** `page` and `rowsPerPage` state variables manage the current page and number of rows per page.
*   **`handleChangePage` and `handleChangeRowsPerPage`:** These functions update the `page` and `rowsPerPage` state when the pagination controls are used.  Critically, changing rows per page resets the `page` to 0.
*   **Slicing the Data:** The `slice()` method is used to display only the rows for the current page.
*   **`emptyRows` Calculation:** This calculates the number of empty rows needed to fill the last page.
*   **`TablePagination` Component:** This component provides the pagination controls. The `rowsPerPageOptions` prop allows you to define the available options for the number of rows per page. The `component="div"` prop ensures that the pagination controls are rendered within a `div` element.

## Advanced Features: Data Grid (MUI X Data Grid)

For more advanced table features like filtering, column resizing, virtualized rendering, and more, consider using the `@mui/x-data-grid` component. This component offers a more comprehensive solution for managing large datasets.

```bash
npm install @mui/x-data-grid
# or
yarn add @mui/x-data-grid
```

Here's a simple example:

```jsx
import React from 'react';
import { DataGrid } from '@mui/x-data-grid';

const columns = [
  { field: 'id', headerName: 'ID', width: 70 },
  { field: 'firstName', headerName: 'First name', width: 130 },
  { field: 'lastName', headerName: 'Last name', width: 130 },
  {
    field: 'age',
    headerName: 'Age',
    type: 'number',
    width: 90,
  },
  {
    field: 'fullName',
    headerName: 'Full name',
    description: 'This column has a value getter and is not sortable.',
    sortable: false,
    width: 160,
    valueGetter: (params) =>
      `${params.row.firstName || ''} ${params.row.lastName || ''}`,
  },
];

const rows = [
  { id: 1, lastName: 'Snow', firstName: 'Jon', age: 35 },
  { id: 2, lastName: 'Lannister', firstName: 'Cersei', age: 42 },
  { id: 3, lastName: 'Lannister', firstName: 'Jaime', age: 45 },
  { id: 4, lastName: 'Stark', firstName: 'Arya', age: 16 },
  { id: 5, lastName: 'Targaryen', firstName: 'Daenerys', age: null },
  { id: 6, lastName: 'Melisandre', firstName: null, age: 150 },
  { id: 7, lastName: 'Clifford', firstName: 'Ferrara', age: 44 },
  { id: 8, lastName: 'Frances', firstName: 'Rossini', age: 36 },
  { id: 9, lastName: 'Roxie', firstName: 'Harvey', age: 65 },
];

function DataGridExample() {
  return (
    <div style={{ height: 400, width: '100%' }}>
      <DataGrid
        rows={rows}
        columns={columns}
        pageSize={5}
        rowsPerPageOptions={[5, 10, 25]}
        checkboxSelection
        disableSelectionOnClick
      />
    </div>
  );
}

export default DataGridExample;
```

**Explanation:**

*   **Installation:** Installs the `@mui/x-data-grid` package.
*   **Columns and Rows:**  Defines the column definitions and data rows. The `columns` array specifies the properties for each column, including the field, header name, width, and type.